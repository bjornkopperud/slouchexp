<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Examples • slouch</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/united/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Examples">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">slouch</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">2.1.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/background.html">Background</a>
    </li>
    <li>
      <a href="../articles/examples.html">Examples</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://github.com/kopperud/slouch">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Examples</h1>
                        <h4 class="author">Jason Pienaar, Bjørn Tore Kopperud, Kjetil Lysne Voje, Thomas F. Hansen (in no particular order)</h4>
            
            <h4 class="date">2018-10-02</h4>
      
      <small class="dont-index">Source: <a href="http://github.com/kopperud/slouch/blob/master/vignettes/examples.Rmd"><code>vignettes/examples.Rmd</code></a></small>
      <div class="hidden name"><code>examples.Rmd</code></div>

    </div>

    
    


<div id="installation-example-data" class="section level1">
<h1 class="hasAnchor">
<a href="#installation-example-data" class="anchor"></a>Installation &amp; example data</h1>
<p>The latest stable version of SLOUCH can be installed from the CRAN (Comprehensive R Archive Network) by entering: </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">"slouch"</span>)</code></pre></div>
<p> The phylogenetic trees used in SLOUCH are encoded as an object of class <code>phylo</code>. Consult the package APE (Analysis of Phylogenetics and Evolution, Paradis <em>et al.</em> 2004) for the base functionality, and auxillary packages such as <code>treeio</code> and <code>ggtree</code> (Yu <em>et al.</em> 2016) for more modern and extensive functionality for importing, exporting or plotting phylogenetic trees in various formats. For the purposes of illustrating the software, we will use a dataset of ruminant neocortices bundled with the package and a corresponding phylogenetic tree (Toljagić <em>et al.</em> 2017). First, we will organize the neocortex data and associated annotation data.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load necessary packages</span>
<span class="kw">library</span>(ape)
<span class="kw">library</span>(slouch)

## Load the phylogenetic tree with annotation data
<span class="kw">data</span>(artiodactyla)
phy &lt;-<span class="st"> </span>artiodactyla

## Load the neocortex dataset
<span class="kw">data</span>(neocortex)

## Plot the tree
<span class="kw">plot</span>(<span class="kw"><a href="http://www.rdocumentation.org/packages/ape/topics/ladderize">ladderize</a></span>(phy), <span class="dt">cex =</span> <span class="fl">0.6</span>)</code></pre></div>
<p><img src="examples_files/figure-html/unnamed-chunk-2-1.png" width="672"></p>
<p>Now, we have a phylogenetic tree with corresponding morphological data for the extant species. If you use your own data to fit models, it is recommended to store the data for the terminal branches in a data frame or in a similar data structure. In order to line up the data frame with the tree, SLOUCH requires the species in the data frame need to be in a particular order.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Check whether they are lined up correctly
neocortex<span class="op">$</span>species <span class="op">==</span><span class="st"> </span>phy<span class="op">$</span>tip.label
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE
## [12]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre></div>
<p> Unsurprisingly, not all of the species are in their correct places; we will have to reorder the data frame. Here is one way to do it. </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">neocortex &lt;-<span class="st"> </span>neocortex[<span class="kw">match</span>(phy<span class="op">$</span>tip.label, neocortex<span class="op">$</span>species), ]

## Check if they line up again
neocortex<span class="op">$</span>species <span class="op">==</span><span class="st"> </span>phy<span class="op">$</span>tip.label
##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## [15] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## [29] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## [43] TRUE</code></pre></div>
<p>The neocortex dataset includes neocortex area, brain mass and body mass in ruminants, primarily bovids. It also includes some ecological information such as the type of habitat (open, closed) or mode of diet (grazer, browser), see <code><a href="../reference/neocortex.html">?neocortex</a></code> for further reference.</p>

</div>
<div id="phylogenetic-effect" class="section level1">
<h1 class="hasAnchor">
<a href="#phylogenetic-effect" class="anchor"></a>Phylogenetic effect</h1>
<p>The idea here is to test whether the phylogenetic relationships have an influence on the distribution of a single variable. Most phylogenetic comparative methods will begin with this step. It is important to realize, however, that phylogenetic effects are not necessarily the same thing as phylogenetic inertia. A variable can be seen to have quite strong phylogenetic effects but such a pattern can easily come about if that variable is evolving towards optima associated with niches that themselves exhibit strong phylogenetic effects. Phylogenetic inertia needs to be measured from the residuals of a model that includes predictor variables that may or may not themselves be phylogenetically structured. First, we plot the neocortex-brain allometry:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">braincentered &lt;-<span class="st"> </span>neocortex<span class="op">$</span>brain_mass_g_log_mean <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(neocortex<span class="op">$</span>brain_mass_g_log_mean)
<span class="kw">plot</span>(<span class="dt">x =</span> braincentered, 
     <span class="dt">y =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean, 
     <span class="dt">xlab =</span> <span class="st">"Mean log brain mass (g)"</span>,
     <span class="dt">ylab =</span> <span class="st">"Mean log neocortex area (mm2)"</span>)</code></pre></div>
<div class="figure">
<img src="examples_files/figure-html/unnamed-chunk-6-1.png" alt="Scatter plot of mean log neocortex area (mm$^2$) on mean log brain mass (g)." width="672"><p class="caption">
Scatter plot of mean log neocortex area (mm<span class="math inline">\(^2\)</span>) on mean log brain mass (g).
</p>
</div>
<p>The way to test for an overall phylogenetic effect in the SLOUCH program is to fit an intercept-only or grand mean model. The program will estimate the phylogenetic half-life <span class="math inline">\(t_{1/2}\)</span> (<span class="math inline">\(t_{1/2} = \log(2)/\alpha\)</span>), and the stationary variance <span class="math inline">\(v_y\)</span> (<span class="math inline">\(= \sigma^2_y / 2 \alpha\)</span>), using likelihood, and the intercept (<span class="math inline">\(b_0\)</span>) using generalized least squares. For now we will use the numerical optimizer (the default setting):</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model0 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean)</code></pre></div>
<p>A minimal overview of <code>model0</code> can be generated by typing <code>print(model0)</code>. The output should be observed with caution until we trust that the hillclimber has converged at a global maximum, or by using a fine-grained grid search to accurately estimate <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(model0)
## Response: neocortex$neocortex_area_mm2_log_mean
## 
##         AICc    Support  R squared 
##  7.055e+01 -3.197e+01 -1.652e-16 
## 
##   ML estimates(s): 
## Phylogenetic half-life:   2595974.1785
## Stationary variance:  42604.985
## 
##   Coefficients: 
## (Intercept) 
##       9.759</code></pre></div>
<p>By entering <code>summary(model0)</code> we get a more detailed summary of the model output. It displays the best estimates of all the parameters where support for the regression parameters are given as standard errors, and log-likelihood values as well as various information criteria for the best estimate model-fit.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(model0)
## Important - Always inspect the likelihood surface of the model parameters with
##           grid search before evaluating model fit &amp; results.
## 
## Maximum-likelihood estimates
##                        Estimate
## Phylogenetic half-life 2595974 
## Stationary variance    42604.98
## 
## 
## Inferred maximum-likelihood parameters
##                                     Value       
## Mean phylogenetic correction factor 3.629961e-06
## Rate of adaptation                  2.670085e-07
## Diffusion variance                  0.02275179  
## 
## 
## Intercepts
##             Estimates Std. error
## (Intercept)  9.759029  0.3679805
## 
## 
## Model fit summary
##               Values
## Support    -3.20e+01
## AIC         6.99e+01
## AICc        7.05e+01
## SIC         7.52e+01
## R squared  -1.65e-16
## SST         4.30e+01
## SSE         4.30e+01
## N (params)  3.00e+00</code></pre></div>
<div id="interpreting-the-parameters" class="section level2">
<h2 class="hasAnchor">
<a href="#interpreting-the-parameters" class="anchor"></a>Interpreting the parameters</h2>
<p>The phylogenetic half-life parameter (<span class="math inline">\(t_{1/2} = \log(2) / \alpha\)</span>) measures the influence of the ancestral state of the variable in question relative to the tendency to evolve towards the common ancestral state (the intercept). Conversely, <span class="math inline">\(\alpha\)</span> measures the rate of adaptation. If the best estimate of <span class="math inline">\(t_{1/2}\)</span> is 0, the ancestral state does not influence the current state of the variable. The larger <span class="math inline">\(t_{1/2}\)</span> gets, the more influence the past state of the variable has on its current state (i.e. the trait‘s evolution approaches a Brownian motion as <span class="math inline">\(t_{1/2}\)</span> approaches infinity). The units of the phylogenetic half-lives are the same units as the branch lengths in the phylogenetic tree, <code>phy$edge.length</code>. The total depth, or distance from the root, can for all nodes be calculated with <code><a href="http://www.rdocumentation.org/packages/ape/topics/node.depth">node.depth.edgelength(phy)</a></code>. For this phylogenetic tree the maximum tree depth is about 27 million years.</p>
</div>
</div>
<div id="adding-predictors-and-testing-for-phylogenetic-inertia" class="section level1">
<h1 class="hasAnchor">
<a href="#adding-predictors-and-testing-for-phylogenetic-inertia" class="anchor"></a>Adding predictors and testing for phylogenetic inertia</h1>
<div id="continuous-random-predictor" class="section level2">
<h2 class="hasAnchor">
<a href="#continuous-random-predictor" class="anchor"></a>Continuous random predictor</h2>
<p>The parameters we estimate for the models that have a single random predictor variable are: <span class="math inline">\(t_{1/2}\)</span>, <span class="math inline">\(\sigma_x^2\)</span>, <span class="math inline">\(v_y\)</span>, and the regression parameters <span class="math inline">\(b_i\)</span>. Recall that the regression parameters <span class="math inline">\(b_i\)</span> can be given in one of two ways, as an evolutionary regression or as an optimal regression where the latter is “corrected” by the phylogenetic correction factor. The predictor variance, <span class="math inline">\(\sigma_x^2\)</span>, is estimated a priori by SLOUCH. The estimation procedure itself is performed in a similar manner as for the intercept-only models above. For example, if we wanted to perform a regression of log neocortex size (<span class="math inline">\(\text{mm}^2\)</span>) on log brain mass (g), we would enter:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">random.cov =</span> braincentered)
model3
## Response: neocortex$neocortex_area_mm2_log_mean
## 
##        AICc   Support R squared 
##  -14.5016   11.7771    0.9145 
## 
##   ML estimates(s): 
## Phylogenetic half-life:   2.5219
## Stationary variance:  0
## 
##   Coefficients: 
##   (Intercept) braincentered 
##         9.668         0.989</code></pre></div>
<div id="measurement-variance-in-the-ruminant-neocortex-example" class="section level3">
<h3 class="hasAnchor">
<a href="#measurement-variance-in-the-ruminant-neocortex-example" class="anchor"></a>Measurement variance in the ruminant neocortex example:</h3>
<p>Comparative analyses based on species averages should consider the estimation error in these averages as measurement error. This is particularly pressing in fields such as evolutionary physiology, where the measurements of individual organisms may be laborious and expensive. Obtaining many measurements from many individuals from many species is difficult, and one often ends up with sample sizes that are small and uneven across species. In such a situation the variance attributable to measurement error can be a substantial fraction of the total, and one wants to weigh the species data according to their reliability. It is also possible that measurement variance may generate a downward bias in estimates of phylogenetic effects, because it makes species appear less statistically correlated than they are in reality. As discussed above, SLOUCH can incorporate measurement variance in both response and predictor variables.</p>
<p>For the neocortex data, estimates of measurement variance can be obtained as the square of the standard error of the species means. There is, however, a practical difficulty in that small sample sizes also makes for unreliable estimates of the measurement variance; the standard error of a species average obtained from a handful of individuals is so inaccurate as to be worthless. We therefore adopted the procedure of assuming that the within-species variance of each variable was the same for all species. The within-species variance estimated average of the sample variances of each variable was estimated as a sample-size-weighted average of the sample variances of each species; i.e. as</p>
<p><span class="math display">\[
\sigma^2_w = \frac{\sum_i \sigma_{wi}^2 (n_i - 1)}{\sum_i (n_i - 1)}
\]</span></p>
<p>where <span class="math inline">\(\sigma_{wi}^2\)</span> is the sample variance of species <span class="math inline">\(i\)</span>, and <span class="math inline">\(n_i\)</span> is the sample size of species <span class="math inline">\(i\)</span>. In this way, the larger sample sizes are weighted more. We then estimated the measurement variance of each species as <span class="math inline">\(\sigma_w^2 / n_i\)</span>. See Grabowski <em>et al.</em> (2016) for further discussion. In order to incorporate measurement variance in the model, would enter:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                     <span class="dt">random.cov =</span> braincentered,
                     <span class="dt">mv.random.cov =</span> neocortex<span class="op">$</span>brain_se_squared)</code></pre></div>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="dt">x =</span> braincentered, 
     <span class="dt">y =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean, 
     <span class="dt">xlab =</span> <span class="st">"Mean log brain mass (g)"</span>,
     <span class="dt">ylab =</span> <span class="st">"Mean log neocortex area (mm2)"</span>)
<span class="kw">abline</span>(model3<span class="op">$</span>beta_evolutionary<span class="op">$</span>coefficients_bias_corr[,<span class="dv">1</span>], 
       <span class="dt">col =</span> <span class="st">"black"</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)
<span class="kw">abline</span>(model3<span class="op">$</span>beta_primary<span class="op">$</span>coefficients_bias_corr[,<span class="dv">1</span>], 
       <span class="dt">col =</span> <span class="st">"orange"</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</code></pre></div>
<div class="figure">
<img src="examples_files/figure-html/unnamed-chunk-12-1.png" alt="The evolutionary (black) and optimal (orange) regression lines for the model of mean log neocortex area (mm$^2$) on mean log brain mass (g), both corrected for bias due to measurement error in mean log brain mass." width="672"><p class="caption">
The evolutionary (black) and optimal (orange) regression lines for the model of mean log neocortex area (mm<span class="math inline">\(^2\)</span>) on mean log brain mass (g), both corrected for bias due to measurement error in mean log brain mass.
</p>
</div>
<p>While the single-optimum model showed a strong phylogenetic signal, this model exhibits much less phylogenetic inertia, with best estimate of the phylogenetic half-life (<span class="math inline">\(t_{1/2}\)</span>) being 1 myr. Here, the optimal regression is steeper than the evolutionary regression. It is also possible to fit a model with multiple continuous covariates, however the input to <code>random.cov</code> must be a matrix or data frame that has column names, and the observational error passed to <code>mv.random.cov</code> must be a matrix or data frame of the same shape as <code>random.cov</code>.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bodycentered &lt;-<span class="st"> </span>neocortex<span class="op">$</span>body_mass_g_log_mean <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(neocortex<span class="op">$</span>body_mass_g_log_mean)
model4 &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
             <span class="dt">species =</span> neocortex<span class="op">$</span>species,
             <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
             <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
             <span class="dt">random.cov =</span> <span class="kw">cbind</span>(braincentered, 
                                bodycentered),
             <span class="dt">mv.random.cov =</span> <span class="kw">cbind</span>(neocortex<span class="op">$</span>brain_se_squared,
                                   neocortex<span class="op">$</span>body_se_squared))
model4
## Response: neocortex$neocortex_area_mm2_log_mean
## 
##        AICc   Support R squared 
##  -13.0466   12.3341    0.9304 
## 
##   ML estimates(s): 
## Phylogenetic half-life:   0
## Stationary variance:  0.0258
## 
##   Coefficients: 
##   (Intercept) braincentered  bodycentered 
##       9.66809       0.74170       0.07619</code></pre></div>
</div>
</div>
<div id="estimating-the-intercept" class="section level2">
<h2 class="hasAnchor">
<a href="#estimating-the-intercept" class="anchor"></a>Estimating the intercept</h2>
<p>The <code>slouch.fit</code> function will on default estimate the intercept <span class="math inline">\(k\)</span>. If the phylogenetic tree is non-ultrametric, for example due to the inclusion of extinct species, it is possible to estimate the components of <span class="math inline">\(k\)</span>. Recall that, when <span class="math inline">\(y\)</span> is evolving according to an Ornstein-Uhlenbeck process in response to one or more predictors <span class="math inline">\(x\)</span> evolving as Brownian motions, the intercept <span class="math inline">\(k\)</span> is</p>
<p><span class="math display">\[
k = e^{-\alpha t}y_a + (1 - e^{- \alpha t})b_0 + (1 - e^{-\alpha t} - \rho(\alpha t))(b_1x_{a1} + b_2x_{a2} + \dots)
\]</span></p>
<p>SLOUCH can independently estimate <span class="math inline">\(y_a\)</span>, <span class="math inline">\(b_0\)</span> and the sum <span class="math inline">\(bx_a = (b_1x_{a1} + b_2x_{a2} + \dots)\)</span>. Using the same example with neocortex evolving in response to brain size, we would specify:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model5 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                     <span class="dt">random.cov =</span> braincentered,
                     <span class="dt">mv.random.cov =</span> neocortex<span class="op">$</span>brain_se_squared,
                     <span class="dt">estimate.Ya =</span> <span class="ot">TRUE</span>,
                     <span class="dt">estimate.bXa =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>The parameters <span class="math inline">\(y_a\)</span> and <span class="math inline">\(bx_a\)</span> represent the ancestral states for <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> separate from the regression intercept <span class="math inline">\(b_0\)</span>. Since this phylogenetic tree is ultrametric, we cannot recover independent estimates of these. If we would try to execute the above code, we would not be able to estimate the GLS coefficients since the model matrix becomes singular. Even if we had a non-ultrametric tree, the intercept components are often estimated with extremely low power, so it can make sense to estimate them as a combined intercept term. This is done by default, or by specifying <code><a href="../reference/slouch.fit.html">slouch.fit(..., estimate.Ya = FALSE, estimate.bXa = FALSE)</a></code> in the function call. The phylogenetic residual covariance matrix will always be computed based on the phylogenetic tree, whether it is ultrametric or not. In some cases (for example, when inertia is small), estimating the components of <span class="math inline">\(k\)</span> will not work (due mainly to numerical issues because of unstable coefficient and parameter combinations in the intercept terms and non-convergence of regression parameters). Also note that, in the non-ultrametric case, each species theoretically has its own optimal intercept (<span class="math inline">\(b_0\)</span>), however the reported estimate is actually an average of these. Its primary purpose is to allow us to plot a regression line.</p>
</div>
<div id="multiple-optima-phylo-format" class="section level2">
<h2 class="hasAnchor">
<a href="#multiple-optima-phylo-format" class="anchor"></a>Multiple optima &amp; phylo-format</h2>
<p>SLOUCH can fit models with multiple adaptive regimes or niches over the branches of the phylogenetic tree. We will fit neocortex size as a function of diet in ruminants. Trees in the <code>phylo</code> format are represented by the edges found in <code>phy$edge</code>, where each edge connects two vertices or nodes. All of the tip nodes have indices starting from 1, 2, 3 … until <span class="math inline">\(n_{tips}\)</span>, in this case 43. The root node has index <span class="math inline">\(n_{tips}\)</span>+1, here 44, and the rest of the internal nodes have indices (<span class="math inline">\(n_{tips}\)</span>+2, <span class="math inline">\(n_{tips}\)</span>+3, …, <span class="math inline">\(n_{nodes}\)</span>). When running this type of model, we will need to specify the internal adaptive regimes in the order of node indices (<span class="math inline">\(n_{tips}\)</span>+1, <span class="math inline">\(n_{tips}\)</span>+2, <span class="math inline">\(n_{tips}\)</span>+3, …, <span class="math inline">\(n_{nodes}\)</span>). The regimes for the tips must be supplied to the <code>fixed.fact</code> argument (<code><a href="../reference/slouch.fit.html">slouch.fit(..., fixed.fact = neocortex$diet)</a></code>), and the regimes for the internal nodes must be assigned to <code>phy$node.label</code>. In order to plot and visually verify that the ancestral state configuration is sensible, we need to have all the regimes in the order of the <strong>edges</strong>, not the nodes. </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Inspect the internal node regimes
## These have order n+1, n+2, n+3 ...
internal_regimes &lt;-<span class="st"> </span><span class="kw">factor</span>(phy<span class="op">$</span>node.label)

## Concatenate tip and internal regimes. These will have order 1,2,3 ...
regimes &lt;-<span class="st"> </span><span class="kw">c</span>(neocortex<span class="op">$</span>diet, internal_regimes)

## Pick out the regimes of the edges, in the order of phy$edge
edge_regimes &lt;-<span class="st"> </span><span class="kw">factor</span>(regimes[phy<span class="op">$</span>edge[,<span class="dv">2</span>]])

<span class="kw">plot</span>(phy, 
     <span class="dt">edge.color =</span> <span class="kw">c</span>(<span class="st">"Black"</span>, <span class="st">"Orange"</span>, <span class="st">"blue"</span>)[edge_regimes], 
     <span class="dt">edge.width =</span> <span class="dv">3</span>, <span class="dt">cex =</span> <span class="fl">0.6</span>)</code></pre></div>
<p><img src="examples_files/figure-html/unnamed-chunk-16-1.png" width="672"></p>
<p> If it looks like there are no visible mistakes, we can go ahead and fit the model in SLOUCH.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model6 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">direct.cov =</span> neocortex<span class="op">$</span>brain_mass_g_log_mean,
                     <span class="dt">fixed.fact =</span> neocortex<span class="op">$</span>diet)

model6
## Response: neocortex$neocortex_area_mm2_log_mean
## 
##        AICc   Support R squared 
##  -16.1789   15.2561    0.9104 
## 
##   ML estimates(s): 
## Phylogenetic half-life:   8.5282
## Stationary variance:  0.0357
## 
##   Coefficients: 
##                              Br                              Gr 
##                          5.3747                          5.6045 
##                              MF neocortex$brain_mass_g_log_mean 
##                          5.5559                          0.8204</code></pre></div>
</div>
<div id="direct-effect-predictors" class="section level2">
<h2 class="hasAnchor">
<a href="#direct-effect-predictors" class="anchor"></a>Direct effect predictors</h2>
<p>SLOUCH can also fit models with continuous covariates that don’t have any phylogenetic covariance structure, variables that influence the optimum directly and immediately.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model7 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                     <span class="dt">direct.cov =</span> neocortex<span class="op">$</span>brain_mass_g_log_mean,
                     <span class="dt">mv.direct.cov =</span> neocortex<span class="op">$</span>brain_se_squared)

model7
## Response: neocortex$neocortex_area_mm2_log_mean
## 
##        AICc   Support R squared 
##  -20.0123   14.5325    0.8994 
## 
##   ML estimates(s): 
## Phylogenetic half-life:   106.2102
## Stationary variance:  0.1481
## 
##   Coefficients: 
##                     (Intercept) neocortex$brain_mass_g_log_mean 
##                          5.4053                          0.8463</code></pre></div>
</div>
</div>
<div id="brownian-motion" class="section level1">
<h1 class="hasAnchor">
<a href="#brownian-motion" class="anchor"></a>Brownian motion</h1>
<div id="univariate-zero-trend" class="section level2">
<h2 class="hasAnchor">
<a href="#univariate-zero-trend" class="anchor"></a>Univariate, zero-trend</h2>
<p>The <code><a href="../reference/brown.fit.html">brown.fit()</a></code> function can fit the same kinds of models that <code><a href="../reference/slouch.fit.html">slouch.fit()</a></code> does, except under a Brownian motion model of evolution.</p>
<p>which in this example has units <span class="math inline">\((\log(\text{neocortex(mm}^2)))^2 \times \text{myr}^{-1}\)</span>.</p>
<p>The parameters <span class="math inline">\(v_y = \sigma_y^2/2\alpha\)</span> and <span class="math inline">\(t_{1/2}\)</span> no longer enter the equation. The intercept-only model can be fitted by entering the following:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model8 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/brown.fit.html">brown.fit</a></span>(<span class="dt">phy =</span> phy,
                    <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                    <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                    <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared)

model8
## Response: neocortex$neocortex_area_mm2_log_mean
## 
##        AICc   Support R squared 
##     68.45    -32.08      0.00 
## 
##   ML estimates(s): 
## Diffusion variance:   0.0225
## 
##   Coefficients: 
## (Intercept) 
##       9.758</code></pre></div>
</div>
<div id="regime-dependent-trends" class="section level2">
<h2 class="hasAnchor">
<a href="#regime-dependent-trends" class="anchor"></a>Regime-dependent trends</h2>
<p>We will fit log neocortex area with different trends for each dietary regime:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model9 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/brown.fit.html">brown.fit</a></span>(<span class="dt">phy =</span> phy,
                    <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                    <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                    <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                    <span class="dt">fixed.fact =</span> neocortex<span class="op">$</span>diet)

model9
## Response: neocortex$neocortex_area_mm2_log_mean
## 
##        AICc   Support R squared 
##   67.2892  -29.1183    0.1292 
## 
##   ML estimates(s): 
## Diffusion variance:   0.0196
## 
##   Coefficients: 
##     Br     Gr     MF 
## 0.3418 0.4079 0.3647</code></pre></div>
<p>In this example, the trends (<span class="math inline">\(\tau\)</span>) are in units of <span class="math inline">\(\log \text{neocortex} (\text{mm}^2) \times \text{myr}^{-1}\)</span>. Since with this procedure we assume that <span class="math inline">\(y_a = 0\)</span>, we can only interpret the relative differences among the trends. By looking at the pairwise contrasts, we can see that the expected increase in neocortex for grazers is slightly larger than for browsers and mixed feeders.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model9<span class="op">$</span>beta_primary<span class="op">$</span>trend_diff
##            Contrast Std. error
## Gr - Br  0.06610920 0.02665333
## MF - Br  0.02296778 0.01602782
## MF - Gr -0.04314142 0.02478017</code></pre></div>
</div>
<div id="trend-as-a-linear-function" class="section level2">
<h2 class="hasAnchor">
<a href="#trend-as-a-linear-function" class="anchor"></a>Trend as a linear function</h2>
<p>We can also fit a model where the trend is expressed as a linear function of another variable (<span class="math inline">\(\tau = a + bx\)</span>). To fit such a model of log neocortex area on log brain mass, we would enter:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model10 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/brown.fit.html">brown.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                     <span class="dt">random.cov =</span> braincentered,
                     <span class="dt">mv.random.cov =</span> neocortex<span class="op">$</span>brain_se_squared)

model10
## Response: neocortex$neocortex_area_mm2_log_mean
## 
##        AICc   Support R squared 
##    4.3028    1.1563    0.9161 
## 
##   ML estimates(s): 
## Diffusion variance:   0
## 
##   Coefficients: 
##   (Intercept) braincentered 
##       9.70542       0.06404</code></pre></div>
<p>Note that even though we model the trend in neocortex size as a function of brain size, there is no information of any net change per time, as we assume that <span class="math inline">\(y_a = 0\)</span>. Thus, we interpret the model either as being zero-“net trend” or being agnostic of the direction of change per time. If we want to get the predictions for this model, we get</p>
<p><span class="math display">\[
y = y_a + a + \rho bx.
\]</span> Substituting <span class="math inline">\(y_a = 0\)</span>, <span class="math inline">\(a = 9.71\)</span>, <span class="math inline">\(\rho = 27.2 \text{myr} / 2\)</span>, <span class="math inline">\(b = 0.064 \text{myr}^{-1}\)</span>, we get the observed allometric relationship between neocortex size (<span class="math inline">\(y\)</span>) and brain size (<span class="math inline">\(x\)</span>):</p>
<p><span class="math display">\[
y = 9.71 + 0.87x.
\]</span> Slouch also computes the observed relationship automatically:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model10<span class="op">$</span>beta_evolutionary<span class="op">$</span>coefficients
##               Predictions Std. error
## (Intercept)     9.7054225 0.24648634
## braincentered   0.8706238 0.07519513</code></pre></div>

</div>
</div>
<div id="measurement-error-and-bias-correction" class="section level1">
<h1 class="hasAnchor">
<a href="#measurement-error-and-bias-correction" class="anchor"></a>Measurement error and bias-correction</h1>
</div>
<div id="grid-search" class="section level1">
<h1 class="hasAnchor">
<a href="#grid-search" class="anchor"></a>Grid search</h1>
<p>Previously we used the numerical optimizer to find maximum-likelihood estimates of <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span>. This technique uses the method “L-BFGS-B” in the <code>optim(...)</code> function to estimate parameters in the OU model, and method “Brent” when <span class="math inline">\(\alpha\)</span> is constrained to zero and the model is reduced to a Brownian motion. On default it will start on a random combination of <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(\sigma_y^2/2\alpha\)</span>, but this may also be specified. While the hillclimber is fast and may seem accurate at first glance, there are some drawbacks. If the likelihood search space has one or more local maxima, the hillclimber may converge at a sub-optimal location and give parameter estimates that are not truly maximum-likelihood estimates. Additionally, even though the hillclimber may converge at some local or global maximum, it will not indicate whether the support region of the parameters is narrow or wide. Another problem when using the hillclimber is that, depending on the specified model, the residual variance-covariance matrix <span class="math inline">\(\mathbf{V}\)</span> may collapse if <span class="math inline">\(\sigma_y^2/2\alpha\)</span> reaches zero. The immediate consequence is that matrix is non-invertible, and the program will return an error. If within-species observational error is non-zero and added to the model, this does not happen. In order to use the hillclimber, it may be necessary to constrain its search space such that <span class="math inline">\(\sigma_y^2/2\alpha\)</span> does not enter zero or close to zero. The exact feasible boundary for this may depend on the scale of the response trait.</p>
<p>The alternative is to use a grid search where we provide vectors of potential values for each parameter to the program to find the combination that maximizes the likelihood. One way to find the best parameters is to start with a rough grid (i.e. values of <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span> incremented by large integer numbers) and then to “home in” on the best supported region with finer scaled grids. Some caution and “trial and error” need to be exercised here as it is possible to miss the support region entirely if the grid values are too widely spaced. There are several ways to create a vector of values in R for this purpose: </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## The manual way
h &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.01</span>, <span class="fl">0.1</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>, <span class="dv">100</span>)
vy &lt;-<span class="st"> </span>h

## Using the seq function
h &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="fl">0.001</span>, <span class="dt">to =</span> <span class="dv">100</span>, <span class="dt">length.out =</span> <span class="dv">15</span>)
vy &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="fl">0.001</span>, <span class="dt">to =</span> <span class="dv">5</span>, <span class="dt">length.out =</span> <span class="dv">15</span>)

## Using a seq function with logarithmically spaced steps
h &lt;-<span class="st"> </span><span class="kw"><a href="../reference/lseq.html">lseq</a></span>(<span class="dt">from =</span> <span class="fl">0.001</span>, <span class="dt">to =</span> <span class="dv">100</span>, <span class="dt">length.out =</span> <span class="dv">15</span>)
vy &lt;-<span class="st"> </span><span class="kw"><a href="../reference/lseq.html">lseq</a></span>(<span class="dt">from =</span> <span class="fl">0.001</span>, <span class="dt">to =</span> <span class="dv">5</span>, <span class="dt">length.out =</span> <span class="dv">15</span>)</code></pre></div>
<p> Using the default values of the model fitting function <code>slouch.fit</code>, we use an initial grid search to find the maximum likelihood estimates of <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span> in a single-optimum model, and change the grid location depending on how the surface looks. When using grid search, it may be easier to explicitly disable the hillclimber technique, i.e. <code>slouch.fit(... hillclimb = FALSE)</code>. </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model_grid_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">hl_values =</span> <span class="kw">seq</span>(<span class="fl">0.001</span>, <span class="dv">12</span>, <span class="dt">length.out =</span> <span class="dv">20</span>),
                     <span class="dt">vy_values =</span> <span class="kw">seq</span>(<span class="fl">0.1</span>, <span class="dv">1</span>, <span class="dt">length.out =</span> <span class="dv">20</span>),
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">hillclimb =</span> <span class="ot">FALSE</span>)
<span class="kw">plot</span>(model_grid_<span class="dv">0</span>)</code></pre></div>
<div class="figure">
<img src="examples_files/figure-html/unnamed-chunk-26-1.png" alt="Three-dimensional joint support region for the estimates of half-lives and stationary variances, for the single-optimum model." width="576"><p class="caption">
Three-dimensional joint support region for the estimates of half-lives and stationary variances, for the single-optimum model.
</p>
</div>
<p>The vertical axis in Figure (…) represents the log-likelihood standardized so that the maximum log-likelihood equals 0. The two horizontal axes are the vector of <code>hl_values</code> and <code>vy_values</code> that we defined in the function arguments. The peak that rises out of the flat surface therefore, represents the specific combination of <code>hl_values</code> and <code>vy_values</code> that are more than two support units below the best estimate. The flat surface itself represents parameter values falling outside the 2-unit support region (as defined by Edwards 1992). If the user prefers to plot an <span class="math inline">\(m\)</span>-unit support region, a support value of <span class="math inline">\(m\)</span> can be specified in <code>slouch.fit</code> by supplying the argument <code><a href="../reference/slouch.fit.html">slouch.fit(... ,support = m)</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model_grid_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">hl_values =</span> <span class="kw">seq</span>(<span class="fl">0.001</span>, <span class="dv">150</span>, <span class="dt">length.out =</span> <span class="dv">20</span>),
                     <span class="dt">vy_values =</span> <span class="kw">seq</span>(<span class="fl">0.1</span>, <span class="fl">2.5</span>, <span class="dt">length.out =</span> <span class="dv">20</span>),
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">hillclimb =</span> <span class="ot">FALSE</span>)

<span class="kw">plot</span>(model_grid_<span class="dv">1</span>)</code></pre></div>
<div class="figure">
<img src="examples_files/figure-html/unnamed-chunk-27-1.png" alt="Another slice of the log likelihood surface for the same single-optimum model" width="576"><p class="caption">
Another slice of the log likelihood surface for the same single-optimum model
</p>
</div>

<p>The plots of the likelihood surfaces are both based on the same data, but with different grid location and resolution. This graphical output is useful for finding and refining the support region where the aim would be to identify the upper and lower 2-unit marginal support regions for <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span>. Note that the support region is relative to the best estimate among the parameters evaluated in the entire parameter search (including parameters evaluated with the hillclimber). Thus it is essential to include the best estimate when calculating the support set. The optima and model fit statistics that are reported in the summary are conditional on the combination of these <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span> that give the highest log-likelihood; in this case the peak of the surface in the likelihood plot. If the grid-search does not contain the true maximum likelihood, the model outputs will reflect this. It is also possible to use other packages to plot the grid-search likelihood surface, for a more aesthetic look (not run).</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(plotly)
p &lt;-<span class="st"> </span><span class="kw">plot_ly</span>(<span class="dt">x =</span> model0<span class="op">$</span>supportplot<span class="op">$</span>hl,
             <span class="dt">y =</span> model0<span class="op">$</span>supportplot<span class="op">$</span>vy,
             <span class="dt">z =</span> model0<span class="op">$</span>supportplot<span class="op">$</span>z) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_surface</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">layout</span>(<span class="dt">title =</span> <span class="st">"Grid-search"</span>,
         <span class="dt">scene =</span> <span class="kw">list</span>(<span class="dt">xaxis =</span> <span class="kw">list</span>(<span class="dt">title =</span> <span class="st">"Phylogenetic half-life"</span>), 
                      <span class="dt">yaxis =</span> <span class="kw">list</span>(<span class="dt">title =</span> <span class="st">"Stationary variance"</span>),
                      <span class="dt">zaxis =</span> <span class="kw">list</span>(<span class="dt">title =</span> <span class="st">"Log-likelihood"</span>)))

p</code></pre></div>


</div>
<div id="references" class="section level1">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<p>Burnham, K. P. &amp; Anderson, D. R. (1998). Model selection and inference: A practical information- theoretic approach. Springer.</p>
<p>Butler, M. A., &amp; King, A. A. (2004). Phylogenetic comparative analysis: a modeling approach for adaptive evolution. American Naturalist, 164(6), 683–695. <a href="https://doi.org/10.1086/426002" class="uri">https://doi.org/10.1086/426002</a></p>
<p>Edwards, A. W. F. (1992). Likelihood. expanded edition Johns Hopkins University Press. Baltimore, MD.</p>
<p>Escudero, M., Hipp, A. L., Hansen, T. F., Voje, K. L., &amp; Luceño, M. (2012). Selection and inertia in the evolution of holocentric chromosomes in sedges (Carex, Cyperaceae). New Phytologist, 195(1), 237–247. <a href="https://doi.org/10.1111/j.1469-8137.2012.04137.x" class="uri">https://doi.org/10.1111/j.1469-8137.2012.04137.x</a></p>
<p>Grabowski, M., Voje, K. L., &amp; Hansen, T. F. (2016). Evolutionary modeling and correcting for observation error support a 3/5 brain-body allometry for primates. Journal of human evolution, 94, 106-116.</p>
<p>Hansen, T. F. (1997). Stabilizing Selection and the Comparative Analysis of Adaptation. Evolution, 51(5), 1341. <a href="https://doi.org/10.2307/2411186" class="uri">https://doi.org/10.2307/2411186</a></p>
<p>Hansen, T. F., &amp; Martins, E. P. (1996). Translating between microevolutionary process and macroevolutionary patterns: the correlation structure of interspecific data. Evolution, 50(4), 1404-1417.</p>
<p>Hansen, T. F., &amp; Orzack, S. H. (2005). Assessing current adaptation and phylogenetic inertia as explanations of trait evolution: the need for controlled comparisons. Evolution, 59(10), 2063-2072.</p>
<p>Hansen, T. F., Pienaar, J., &amp; Orzack, S. H. (2008). A comparative method for studying adaptation to a randomly evolving environment. Evolution, 62(8), 1965–1977. <a href="https://doi.org/10.1111/j.1558-5646.2008.00412.x" class="uri">https://doi.org/10.1111/j.1558-5646.2008.00412.x</a></p>
<p>Hansen, T. F., &amp; Bartoszek, K. (2012). Interpreting the evolutionary regression: The interplay between observational and biological errors in phylogenetic comparative studies. Systematic Biology, 61(3), 413–425. <a href="https://doi.org/10.1093/sysbio/syr122" class="uri">https://doi.org/10.1093/sysbio/syr122</a></p>
<p>Hansen, T. F. (2014). Use and misuse of comparative methods in the study of adaptation. In Garamszegi &amp; L. Zsolt (Eds.), Modern Phylogenetic Comparative Methods and their Application in Evolutionary Biology (pp. 351–379). Springer. <a href="https://doi.org/10.1007/978-3-662-43550-2_14" class="uri">https://doi.org/10.1007/978-3-662-43550-2_14</a></p>
<p>Harvey, P. H., &amp; Pagel, M. D. (1991). The comparative method in evolutionary biology (Vol. 239). Oxford: Oxford university press.</p>
<p>Martins, E. P., &amp; Hansen, T. F. (1997). Phylogenies and the comparative method: a general approach to incorporating phylogenetic information into the analysis of interspecific data. The American Naturalist, 149(4), 646-667.</p>
<p>O’Meara, B. C., &amp; Beaulieu, J. M. (2014). Modelling stabilizing selection: The attraction of Ornstein-Uhlenbeck models. In Garamszegi &amp; L. Zsolt (Eds.), Modern Phylogenetic Comparative Methods and their Application in Evolutionary Biology (pp. 381–393). Springer. <a href="https://doi.org/10.1007/978-3-662-43550-2_15" class="uri">https://doi.org/10.1007/978-3-662-43550-2_15</a></p>
<p>Labra, A., Pienaar, J., &amp; Hansen, T. F. (2009). Evolution of Thermal Physiology in Liolaemus Lizards: Adaptation, Phylogenetic Inertia, and Niche Tracking. The American Naturalist, 174(2), 204–220. <a href="https://doi.org/10.1086/600088" class="uri">https://doi.org/10.1086/600088</a></p>
<p>Ridley, M. (1983). The explanation of organic diversity: the comparative method and adaptations for mating. Oxford University Press, USA.</p>
<p>Toljagić, O., Voje, K. L., Matschiner, M., Liow, L. H., &amp; Hansen, T. F. (2017). Millions of years behind: Slow adaptation of ruminants to grasslands. Systematic Biology, (318). <a href="https://doi.org/10.1093/sysbio/syx059" class="uri">https://doi.org/10.1093/sysbio/syx059</a></p>
<p>Sober, E. (2008). Evidence and evolution: The logic behind the science. Cambridge University Press.</p>
<p>Beaulieu, J. M., Jhwueng, D. C., Boettiger, C., &amp; O’Meara, B. C. (2012). Modeling stabilizing selection: expanding the Ornstein–Uhlenbeck model of adaptive evolution. Evolution, 66(8), 2369-2383.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#installation-example-data">Installation &amp; example data</a></li>
      <li>
<a href="#phylogenetic-effect">Phylogenetic effect</a><ul class="nav nav-pills nav-stacked">
<li><a href="#interpreting-the-parameters">Interpreting the parameters</a></li>
      </ul>
</li>
      <li>
<a href="#adding-predictors-and-testing-for-phylogenetic-inertia">Adding predictors and testing for phylogenetic inertia</a><ul class="nav nav-pills nav-stacked">
<li><a href="#continuous-random-predictor">Continuous random predictor</a></li>
      <li><a href="#estimating-the-intercept">Estimating the intercept</a></li>
      <li><a href="#multiple-optima-phylo-format">Multiple optima &amp; phylo-format</a></li>
      <li><a href="#direct-effect-predictors">Direct effect predictors</a></li>
      </ul>
</li>
      <li>
<a href="#brownian-motion">Brownian motion</a><ul class="nav nav-pills nav-stacked">
<li><a href="#univariate-zero-trend">Univariate, zero-trend</a></li>
      <li><a href="#regime-dependent-trends">Regime-dependent trends</a></li>
      <li><a href="#trend-as-a-linear-function">Trend as a linear function</a></li>
      </ul>
</li>
      <li><a href="#measurement-error-and-bias-correction">Measurement error and bias-correction</a></li>
      <li><a href="#grid-search">Grid search</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Bjørn Tore Kopperud, Jason Pienaar, Kjetil Lysne Voje, Steven Hecht Orzack, Thomas F. Hansen.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
