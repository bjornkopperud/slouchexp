<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Manual • slouch</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/united/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="Manual">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">slouch</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">2.1.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/introduction.html">Slouch introduction</a>
    </li>
    <li>
      <a href="../articles/manual.html">Manual</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://github.com/kopperud/slouch">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Manual</h1>
                        <h4 class="author">–</h4>
            
            <h4 class="date">2018-04-19</h4>
      
      <small>Source: <a href="http://github.com/kopperud/slouch/blob/master/vignettes/manual.Rmd"><code>vignettes/manual.Rmd</code></a></small>
      <div class="hidden name"><code>manual.Rmd</code></div>

    </div>

    
    
<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p>This document describes an R-package for estimating parameters for a suite of comparative methods based on the Ornstein-Uhlenbeck process as a model of adaptive evolution. We refer to this program as SLOUCH 2.0 since it builds on the models in SLOUCH 1.0 (Hansen <em>et al.</em> 2008). SLOUCH 1.0 dealt with a continuous trait that evolves as an Ornstein-Uhlenbeck process around an optimal state that itself depend on an environmental variable that evolves as if by a Brownian motion. For the current version we have extended the model to deal with an optimal state that depends on multiple randomly evolving predictors and multiple direct effect predictors. We also describe in more detail how to include measurement error in the analyses. SLOUCH 2.0 also includes functionality designed to deal with traits that evolve in response to fixed categorical niches that can be mapped onto a phylogeny and then used to estimate niche optima for the response trait (Hansen, 1997; Butler &amp; King, 2004). The multi-optima model is thus an alternative to Butler &amp; King’s (2004) OUCH program, but it differs in a few crucial apects, as described below. SLOUCH 1.3 and earlier versions were built as an addition to OUCH, and data formats and some functions were borrowed from the original version of OUCH, either as is, or slightly modified. In SLOUCH 2.0 the phylogenetic tree format is revamped, and now uses the format used by the R-package APE (Paradis <em>et al.</em> 2004).</p>
<p>The fixed.fit function of SLOUCH 1.1 differs from the OUCH program as follows: a) it allows the user to estimate parameters using a non-ultrametric tree, such as those that include extinct species, b) it allows the user to incorporate measurement error in the response variable, c) it automatically calculates standard errors for estimated optima, goodness of fit as <span class="math inline">\(\text{R}^2\)</span> and can be used to compute support regions for rates of adaptation and trait variances, d) it includes functionality to use both grid search and the built-in R optimizing functions to estimate parameters, and e) it includes various options to deal with intercept estimation, which can be problematic. [Do we need to compare with OUCH?]</p>
<p>SLOUCH 2.0 also includes Brownian-motion models where the optima are instead modeled as trends. This document is written to serve as an updated user manual for SLOUCH 2.0. It provides a summary of the rationale for the methods, and illustrates them with examples based on the Liolaemus (ungulate teeth?) data set. It extends the user manual for SLOUCH 1.0 by discussing multiple regression and ANOVA type of models for the optimum, and gives more details on modeling non-ultrametric trees and measurement error. The mathematical and conceptual basis of the adaptation-inertia methods are presented and discussed in Hansen (1997), Butler &amp; King (2004), and Hansen et al. (2008). A user of SLOUCH 2.0 should also consult these papers.</p>



</div>
<div id="comparative-methods-for-adaptive-hypotheses" class="section level1">
<h1 class="hasAnchor">
<a href="#comparative-methods-for-adaptive-hypotheses" class="anchor"></a>Comparative methods for adaptive hypotheses</h1>
<div id="background" class="section level2">
<h2 class="hasAnchor">
<a href="#background" class="anchor"></a>Background</h2>
<p>Comparing the trait values of groups of related species to their predicted optima in different environments or time periods can provide powerful tests of adaptive hypotheses (e.g. Ridley 1983; Harvey &amp; Pagel 1991). The distributions of current species trait values at the current tips of a phylogeny (and fossil data or reconstructed ancestral states within the phylogeny if available) however, may reflect, adaptation, phylogenetic inertia, both of these, or none of these. We use the term phylogenetic inertia in the sense of resistance to adaptive change i.e. it comes about when related species inherit an inert trait from a common ancestor, which then resists adaptive change to new optima. Hence, if inertia is present, observed trait values may reflect both adaptive change as well as an ancestral trait influence. When testing an adaptive hypothesis with such data, the constraints provided by such resistance to change for current trait values as they evolve towards their optima need to be controlled for (and similarly, the effects of adaptation need to be controlled for when testing hypothesis of phylogenetic inertia).</p>
<p>Most contemporary comparative methodologies do not control for inertia in the sense defined above, but rather control for general effects of phylogeny. Their principal concern is to deal with statistical issues that arise from non-independent, correlated data that naturally arise from evolution along a branching phylogeny, and are usually used to remove these correlations before the actual analysis takes place. Phylogenetic effects, however, will also be present when traits adapt to variables that are themselves phylogenetically structured. Such effects should not be controlled for when studying adaptation and need to be separated from inertia. Furthermore, most contemporary methods assume that traits evolve as a Brownian motion, a crucial assumption and one that provides the analytical techniques to remove the correlations (e.g. independent contrasts). Numerous studies however, have pointed out that comparative method that assumes a Brownian motion as the underlying evolutionary process are not suitable for studying adaptation towards optima (e.g. Hansen &amp; Orzack, 2005). A Brownian-motion process consists only of a stochastic component, where the expected mean value must equal the common ancestral state at the base of the species phylogeny. There is no mechanism in the process that allows one to specify adaptation to or maintenance at specific optima. Even if the ancestral state is at the optimum and the optimum does not change through time, any deviations from the optimum relationship generated by the stochastic Brownian-motion process will be inherited and there is no mechanism that allows a single species trait to return to its optimum value.</p>
<p>Hansen (1997), Butler &amp; King (2004), Hansen &amp; Orzack (2005) and Hansen <em>et al.</em> (2008) have shown that comparative methods based on an Ornstein-Uhlenbeck (OU) process are more suited to studying adaptive hypotheses using comparative data. The OU process, unlike a pure Brownian motion, consists of a deterministic component (which can be used to model adaptation of a trait towards an optimum) as well as a stochastic component (which models the random fluctuations of the trait as it evolves towards the optimum (see equations below). In fact if we take away the deterministic component of an OU process, we are left with a Brownian motion.</p>
</div>
<div id="comparative-methods-built-around-an-ornstein-uhlenbeck-process" class="section level2">
<h2 class="hasAnchor">
<a href="#comparative-methods-built-around-an-ornstein-uhlenbeck-process" class="anchor"></a>Comparative methods built around an Ornstein-Uhlenbeck process</h2>
<p>The Ornstein-Uhlenbeck process describes stochastic evolution with a deterministic tendency to move towards a fixed state (Hansen &amp; Martins 1996). To model adaptive evolution in a comparative data set, we interpret this fixed state as a “primary optimum”, defined as the average fitness optimum that would be reached by a large number of independent species evolving for a sufficiently long time in a given niche to be free of any ancestral influence (Hansen 1997). The model assumes that primary optima exist at any point in time (on the phylogeny), and the idea is to test hypotheses about the effect of specified environmental variables on the primary optima. Currently, the software allows the primary optimum to be be modeled as a multiple regression on several continuous “random” variables, or as a one-way ANOVA on fixed, categorical variables. If we let <span class="math inline">\(\theta(x_1, x_2 \dots)\)</span>, be the primary optimum as a function of environmental variables, <span class="math inline">\(x_1, x_2 \dots\)</span>, then for the regression model, we have:</p>
<p><span class="math display">\[
\theta(x_1, x_2 \dots) = b_0 + b_1x_1 + b_2x_2 \dots
\]</span></p>
<p>where <span class="math inline">\(b_0\)</span> is an intercept, and <span class="math inline">\(b_1, b_2 \dots\)</span> are regression slopes on the environmental variables. For the ANOVA model we let <span class="math inline">\(x_1, x_2 \dots\)</span> be indicator variables indicating different categorical states of the environment, and we write</p>
<p><span class="math display">\[
\theta(x_1, x_2 \dots) = \theta_1x_1 + \theta_2x_2 \dots
\]</span> where <span class="math inline">\(\theta_1x_1, \theta_2x_2 \dots\)</span> are parameters describing the state of the primary optimum in the different environments or niches. The goal is to estimate the parameters <span class="math inline">\(b_i\)</span> or <span class="math inline">\(\theta_i\)</span> to test whether particular aspects of the environment have an effect on the optimum or not. Our adaptive hypotheses thus takes the form: Given that there is a single optimum, the species are adapted to variable <span class="math inline">\(x\)</span> if <span class="math inline">\(x\)</span> has an (important) effect on the optimum. As we will see, the methods also allow for assessments of how strongly the species tend to evolve towards the optimum, and thus to reject the base assumption of adaptation altogether. In both the fixed and random predictor cases, the evolution of the response traits, <span class="math inline">\(y\)</span>, can be represented by the stochastic differential Ornstein-Uhlenbeck process equation:</p>
<p><span class="math display">\[
dy = -\alpha(y - \theta)dt + \sigma_ydW_y
\]</span></p>
<p>which is interpreted as follows: <span class="math inline">\(dy\)</span> is the change in <span class="math inline">\(y\)</span> over a time step dt, <span class="math inline">\(\alpha\)</span> is a parameter measuring the rate of adaptation towards the optimum, <span class="math inline">\(dW_y\)</span> is a white-noise process having independent, normally- distributed random changes with mean zero and unit variance. The standard deviation of the random changes is given by <span class="math inline">\(\sigma_y\)</span> and <span class="math inline">\(\theta\)</span> are the fixed or random optima as defined above. Categorical predictor variables must be mapped on the phylogeny a priori. The method treats these as known. For the random predictors we have an additional stochastic differential Brownian-motion process to describe their evolution on a phylogeny:</p>
<p><span class="math display">\[
dx = \sigma_xdW_y
\]</span></p>
<p>where <span class="math inline">\(\sigma_x\)</span> gives the standard deviation of the random changes (hence the rate at which the predictors change). These dynamical equations can be solved for the different assumptions about the optimum. With fixed, categorical predictor variables, the model predicts that the species data will be of the form:</p>
<p><span class="math display">\[
y_i = c_{0i}y_a + c_{1i}\theta_1 + c_{2i}\theta_2 \dots + r_i
\]</span> where <span class="math inline">\(y_a\)</span> is a parameter describing the state of the trait at the root of the tree, the coefficients, <span class="math inline">\(c_{ji}\)</span> , are determined by the time on the phylogeny the species <span class="math inline">\(i\)</span> has spent in environment <span class="math inline">\(j\)</span>, such that more recent environments are weighted more than more ancient environments. The weights are determined by the rate of adaptation, <span class="math inline">\(\alpha\)</span>. More specifically, <span class="math inline">\(c_{ji}\)</span> is a sum over all time intervals in the past history of species <span class="math inline">\(i\)</span> where this species experienced environment <span class="math inline">\(j\)</span>, and each interval contributes a term <span class="math inline">\(e^{-\alpha t} - e^{\alpha s}\)</span>, where <span class="math inline">\(t\)</span> is the time back to the end of the interval, and <span class="math inline">\(s\)</span> is the time back to the beginning of the interval (see Hansen (1997) for formal derivation). The coefficient for the parameter <span class="math inline">\(y_a\)</span> is <span class="math inline">\(c_0 = e^{ -\alpha t}\)</span> , where <span class="math inline">\(t\)</span> is the time from the root to species <span class="math inline">\(i\)</span>. Note that if <span class="math inline">\(\alpha\)</span> is large, then only the most recent environment will contribute. Ancient environments only contribute if the rate of adaptation is low. SLOUCH will automatically compute these coefficients given a mapping of niches on the tree. The residual terms, <span class="math inline">\(r_i\)</span>, are assumed to be normally distributed with mean zero and variances and covariances given later. These are also computed automatically.</p>
<p>For random, continuous predictor variables, evolving as if by a Brownian motion, the model predicts:</p>
<p><span class="math display">\[
y_i = k + \rho(\alpha t_i)b_1x_{1i} + \rho(\alpha t_i)b_2x_{2i} \dots + r_i
\]</span></p>
<p>where <span class="math inline">\(x_{ij}\)</span> is the current state of predictor variable <span class="math inline">\(j\)</span> for species <span class="math inline">\(i\)</span>. The intercept (<span class="math inline">\(k\)</span>) is discussed below, and <span class="math inline">\(\rho(\alpha t_i)\)</span> is a “phylogenetic correction factor”, given as:</p>
<p><span class="math display">\[
\rho(\alpha t_i) = (1 - \frac{1 - e^{-\alpha t_i}}{\alpha t_i})
\]</span> where <span class="math inline">\(t_i\)</span> is the time from root to species <span class="math inline">\(i\)</span>. On ultrametric trees, this factor is identical for all species. The correction factor varies between 0 and 1. It describes how phylogenetic inertia makes the “evolutionary” regressions of y on x less steep than the underlying “optimal” regressions, <span class="math inline">\(b\)</span>. If the rate of adaptation or the time back to the origin of the radiation are very high, <span class="math inline">\(\rho(\alpha t_i) = 1\)</span>, and the evolutionary regression will equal the optimal regression. The residual terms, <span class="math inline">\(r_i\)</span>, are normally distributed with mean zero and variances and covariances given later. The residuals and the phylogenetic correction factors are computed automatically by SLOUCH, and both evolutionary and optimal regressions are returned. In addition to estimating the parameters, <span class="math inline">\(\theta\)</span> or <span class="math inline">\(b\)</span>, describing the relationship of the primary optimum to the environmental variables, we also need to estimate the parameters <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\sigma_y\)</span> describing the rate of evolution, and in the random evironment model, we also need the rate of evolution of the environment, <span class="math inline">\(\sigma_x\)</span>. The estimation methods are described below. Here, we just note that we will work with the transformed parameters:</p>
<p><span class="math display">\[
\begin{aligned}
t_{1/2} =&amp; \frac{\log(2)}{\alpha} \\
v_y =&amp; \frac{\sigma^2_y}{2\alpha}
\end{aligned}
\]</span> These are both easier to interpret and easier to estimate than <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\sigma_y\)</span> . The phylogenetic half life, <span class="math inline">\(t_{1/2}\)</span>, is the time it takes for the expected trait value to move half the distance from the ancestral state to the primary optimum. The half life provides a useful metric to asses the strength of phylogenetic inertia as it is on the same linear scale as the phylogenetic branch lengths. If the half life is short relative to phylogeny, it means that adaptation to the primary optimum is rapid in expectation, and if the half life is long, it means that ancestral influences constrain the adapting trait. Consequently, if large, we would expect the species traits to be poorly adapted to the primary niches. A half life of infinity corresponds to evolution governed by a Brownian-motion process where there is no tendency to move towards the optimum, and a half life of zero corresponds to instant adaptation. The parameter <span class="math inline">\(v_y\)</span> is the variance expected when the adaptive and stochastic forces are in stochastic equilibrium. The residual variances and covariances of the fixed-effect model were derived in Hansen (1997). They are</p>
<p><span class="math display">\[
\begin{aligned}
\text{Var}[r_i] &amp;= v_y(1 - e^{-\alpha t_i}) \\
\text{Cov}[r_i, r_j] &amp;= v_y e^{-\alpha t_{ij}}(1 - e^{-2 \alpha t_a})
\end{aligned}
\]</span> where <span class="math inline">\(t_i\)</span> is the time from root to species <span class="math inline">\(i\)</span>, <span class="math inline">\(t_a\)</span> is the time from root to the most recent common ancestor of species <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, and <span class="math inline">\(t_{ij}\)</span> is the time separating species <span class="math inline">\(i\)</span> from species <span class="math inline">\(j\)</span> (i.e. the sum of the distances from <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> to their most recent common ancestor). For the random effect model, Hansen <em>et al.</em> (2008) derived the residual covariances as:</p>
<p><span class="math display">\[
\begin{aligned}
\text{Cov}[r_i, r_j] &amp;= (\frac{\sigma^2_{\theta} + \sigma^2_{y} }{2\alpha}) (1 - e^{-2\alpha t_a})e^{-\alpha t_{ij}} + \\
\sigma^2_{\theta}(t_a \frac{1 - e^{-at_i}}{\alpha t_i} \frac{1 - e^{-at_j}}{\alpha t_j} - &amp;\frac{1 - e^{-at_a}}{\alpha}(e^{-\alpha t_{ia}} \frac{1 - e^{-\alpha t_j}}{\alpha t_j} + e^{-\alpha t_{ja}} \frac{1 - e^{-\alpha t_i}}{\alpha t_i}))
\end{aligned}
\]</span></p>
<p>The parameter <span class="math inline">\(\sigma^2_\theta\)</span> in the above equation equals <span class="math inline">\(b_1^2\sigma_{x1}^2 + b_2^2\sigma_{x2}^2 + \dots\)</span>, assuming the predictor variables are not correlated. The instantaneous variances, <span class="math inline">\(\sigma_{xi}^2\)</span>, of the predictor variables are estimated in advance. Note that this is considerably more complex than with fixed effects, and also depend on the regression parameters <span class="math inline">\(b_i\)</span>. SLOUCH uses an iterated estimation procedure to account for the effects of the regression parameters in the residual variance matrix.</p>
</div>
<div id="estimation-specifics" class="section level2">
<h2 class="hasAnchor">
<a href="#estimation-specifics" class="anchor"></a>Estimation specifics</h2>
<p>The intercept, <span class="math inline">\(k\)</span>, in the random-effect model is given as:</p>
<p><span class="math display">\[
k = e^{-\alpha t}y_a + (1 - e^{- \alpha t})b_0 + (1 - e^{-\alpha t} - \rho(\alpha t))(b_1x_{a1} + b_2x_{a2} + \dots)
\]</span></p>
<p>where <span class="math inline">\(y_a\)</span> and <span class="math inline">\(x_{aj}\)</span> are the ancestral states of the trait, <span class="math inline">\(y\)</span>, and the predictor variables, <span class="math inline">\(x_j\)</span>, and <span class="math inline">\(b_0\)</span> is the true intercept of the optimal regression. As <span class="math inline">\(t\)</span> is the time from root to the species, we also see that the intercept on a non-ultrametric tree will differ from species to species. Clearly, <span class="math inline">\(k\)</span> is not a parameter of biological interest. What we would like is to get estimates of its components, and in particular of the “optimal” intercept, <span class="math inline">\(b_0\)</span>. For species on a non-ultrametric phylogeny, it is technically possible to get independent estimates of <span class="math inline">\(b_0, y_a\)</span> and the <span class="math inline">\(x_a\)</span>’s, but unless the phylogeny is strongly non-ultrametric, these would be poorly resolved, and the individual estimates are likely to be highly unreliable. We generally do not recommend separate estimates of these parameters, and for an ultrametric phylogeny, we can only obtain an estimate of the composite <span class="math inline">\(k\)</span>. An estimate of the optimal intercept may, however, be obtained indirectly with an additional assumption. First, note that SLOUCH returns independent estimates of the ancestral states <span class="math inline">\(x_a\)</span> based on the assumption that the predictors evolve as if by a Brownian motion. The problem is then only to get an estimate of the ancestral state of the trait, <span class="math inline">\(y_a\)</span>. One resonable way to do this is to assume that the common ancestor was optimal, and use <span class="math inline">\(y_a = b_0 + b_1x_{a1} + b_2x_{a2} \dots\)</span>. From this we can derive an estimate of the optimal intercept as:</p>
<p><span class="math display">\[
b_0 = k + (\rho(\alpha t) - 1)(b_1x_{a1} + b_2x_{a2} \dots)
\]</span> where <span class="math inline">\(k, b\)</span>’s, <span class="math inline">\(x_a\)</span>’s and <span class="math inline">\(\rho(\alpha t)\)</span> are all output from the SLOUCH analysis. This may be useful for plotting of the optimal regression, etc. The error due to ancestral optimality is likely to be very small unless the phylogenetic half-life is very large.</p>
</div>
<div id="model-selection" class="section level2">
<h2 class="hasAnchor">
<a href="#model-selection" class="anchor"></a>Model selection</h2>
<p>SLOUCH output provides the user with various information criteria in order to compare models with different combinations of predictor variables. These are the AIC, the small small size corrected AIC (AICc) and the stricter SIC (Burnham &amp; Anderson, 1998). For continuous predictor models, these criteria can be used to reduce the number of informative predictors in a multiple regression, or to decide which is the best predictor of a given trait‘s evolution. These information criteria can also be used to decide whether a single or multiple optima Ornstein-Uhlenbeck process or a Brownian-Motion process best describes a trait’s evolution. For models with fixed categorical predictors, these information criteria are useful for assessing which categories influence a trait’s evolution. In this way the user can either pool different categories or further subdivide a given category into biological meaningful categories in order to test various hypotheses concerning differential selective niches. We note however, that the information criteria will sometimes pick models with very strange parameter estimates like optima or ancestral states that are way out of biological bounds, or stationary variances of zero. Such models should be regarded with skepticism, and one should look at the support surfaces (see below) to see if there are other peaks in the likelihood surface with more reasonable estimates.</p>
</div>
<div id="measurement-variance" class="section level2">
<h2 class="hasAnchor">
<a href="#measurement-variance" class="anchor"></a>Measurement variance</h2>
<p>Martins &amp; Hansen (1997) and Ives <em>et al.</em> (2007) discuss how to incorporate measurement error into a phylogenetic comparative analysis. Most often, a comparative analysis involves using species means as input values. In this case the main component of measurement error is estimation error in the mean (or whatever other statistics are used) resulting from sampling a finite number of individuals. If each mean species value to be used in the regression was obtained from a large number of individuals (&gt; 20-30 or so) the square of the standard error (i.e. the estimation variance) can be entered into the measurement error column for that variable. If no measurement error is to be included, then simply add a column of zeros (this can also be done in R itself by specifying a vector of zeros of length <span class="math inline">\(n\)</span>, the number of species). We also refer the reader to the section below entitled measurement variance in the Liolaemus example for a more detailed example. SLOUCH deals with measurement error in the response variable by adding measurement variance to the diagonals of the residual variance matrix. Measurement variance in the random predictor variable(s) is incorporated by multiplying it by the square of the uncorrected slope parameter and then adding it to the diagonals of the residual variance matrix in the manner of an iterated generalized least squares (GLS) estimation. Measurement covariance between response and predictor variables can be incorporated by adding two times the measurement covariance times the uncorrected slope parameters to the variance matrix (not yet implemented). If the observational errors in the predictor variables are non-zero, the generalized least squares estimator may be biased. A bias correction for the regression coefficients is implemented according to Hansen &amp; Bartoszek (2012).</p>
</div>
<div id="caveats-and-limitations" class="section level2">
<h2 class="hasAnchor">
<a href="#caveats-and-limitations" class="anchor"></a>Caveats and limitations</h2>
<p>As with any statistical model, the quality of the parameter estimates is dependent on the quality of the data and certain assumptions concerning the residuals must be met. SLOUCH utilizes both measured trait values and the phylogenetic topology and branch lengths as data. With regards to the trait values, we assume that a linear relationship exists between expected optimal trait values and the predictor variables. Although we could perform non-linear regression by entering quadratic terms in the model, this will most likely violate the assumption that the predictors evolve as a Brownian Motion and consequently we do not recommend this. It should also be kept in mind that any inferences drawn about the rates of adaption, phylogenetic inertia and its potential effects on trait values are conditional on the phylogeny used. Unfortunately SLOUCH does not at this time include routines for evaluating the effects of phylogeny uncertainty. We recommend performing the analysis on plausible alternative phylogenetic hypotheses to examine the effects of phylogenetic uncertainty on parameter estimates. Simulation may also be useful here for examining potential interactions between true parameter values and alternative phylogenies.</p>
</div>
</div>
<div id="data-requirements" class="section level1">
<h1 class="hasAnchor">
<a href="#data-requirements" class="anchor"></a>Data requirements</h1>
<div id="checklist" class="section level2">
<h2 class="hasAnchor">
<a href="#checklist" class="anchor"></a>Checklist</h2>
<ol style="list-style-type: decimal">
<li>A rooted phylogeny with branch lengths. Both ultrametric and non-ultrametric trees can be used, but this will have implications for reliable estimation of ancestral states. Polytomies and non-branching edges are not a problem but each branch must have a length. The units of the lengths are arbitrary and can be given in time units or number of nucleotide substitutions. A lot of the power of this method comes from having accurate branch lengths and topologies so some care should be taken in obtaining these.</li>
<li>Measurements of a continuous response variable and one or more continuous predictor variables for the species at the tips of the phylogeny or a fixed predictor variable with different levels to represent different fixed niches. Missing values are not allowed. The observational or measurement errors of the continuous response and predictor variables can and should be included and accounted for.</li>
<li>An adaptive hypothesis relating the response variable to the predictors. The idea of the OU models is that the response variables evolve towards optima that are estimated by the methods.</li>
<li>A computer with the R program on it. This is freeware and versions for Windows, MacOS and GNU/Linux can be downloaded from <a href="https://www.r-project.org/" class="uri">https://www.r-project.org/</a>.</li>
</ol>
</div>
<div id="installing-slouch-and-loading-the-tree" class="section level2">
<h2 class="hasAnchor">
<a href="#installing-slouch-and-loading-the-tree" class="anchor"></a>Installing SLOUCH and loading the tree</h2>
<p>The source code for the developmental version of SLOUCH is available at <a href="https://www.github.com/kopperud/slouch" class="uri">https://www.github.com/kopperud/slouch</a>, or can be obtained from the authors at request. The latest stable version of SLOUCH, including its dependencies, can be installed from the CRAN (Comprehensive R Archive Network) by entering the following command: </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">"slouch"</span>)</code></pre></div>
<p> The phylogenetic trees used in SLOUCH are encoded as an object of class <code>phylo</code>. Consult the package APE (Analysis of Phylogenetics and Evolution, Paradis <em>et al.</em> 2004) for the base functionality, and perhaps auxillary packages such as <code>treeio</code> and <code>ggtree</code> (Yu <em>et al.</em> 2016) for more modern and extensive functionality when importing, exporting or plotting phylogenetic trees from various formats. For the purposes of illustrating syntax, we will use a dataset of artiodactyl neocortices bundled with the package (see <code><a href="../reference/neocortex.html">?neocortex</a></code>), and a corresponding phylogenetic tree (Toljagić <em>et al.</em> 2017). First, we will organize the neocortex data and associated annotation data.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load necessary packages</span>
<span class="kw">library</span>(ape)
<span class="kw">library</span>(slouch)

## Load the phylogenetic tree with annotation data
<span class="kw">data</span>(artiodactyla)
phy &lt;-<span class="st"> </span>artiodactyla

## Load the neocortex dataset
<span class="kw">data</span>(neocortex)

## Plot the tree
<span class="kw">plot</span>(<span class="kw"><a href="http://www.rdocumentation.org/packages/ape/topics/ladderize">ladderize</a></span>(phy), <span class="dt">cex =</span> <span class="fl">0.6</span>)</code></pre></div>
<p><img src="manual_files/figure-html/unnamed-chunk-2-1.png" width="672"></p>
<p>Now, we have a phylogenetic tree with corresponding morphological data for all of the extant species. If you use your own data to fit models, it is recommended to store the data for the terminal branches in a data frame or in a similar data structure. In order to line up the data frame with the tree, SLOUCH requires the species in the data frame need to be in a particular order.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Check whether they are lined up correctly
neocortex<span class="op">$</span>species <span class="op">==</span><span class="st"> </span>phy<span class="op">$</span>tip.label</code></pre></div>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE
## [12]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<p> Unsurprisingly, not all of the species are in their correct places; we will have to reorder the data frame. Here is one way to do it. </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">neocortex &lt;-<span class="st"> </span>neocortex[<span class="kw">match</span>(phy<span class="op">$</span>tip.label, neocortex<span class="op">$</span>species), ]

## Check if they line up again
neocortex<span class="op">$</span>species <span class="op">==</span><span class="st"> </span>phy<span class="op">$</span>tip.label</code></pre></div>
<pre><code>##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## [15] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## [29] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## [43] TRUE</code></pre>
<div id="measurement-variance-in-the-artiodactyl-neocortex-example" class="section level3">
<h3 class="hasAnchor">
<a href="#measurement-variance-in-the-artiodactyl-neocortex-example" class="anchor"></a>Measurement variance in the artiodactyl neocortex example:</h3>
<p>Comparative analyses based on species averages should consider the estimation error in these averages as measurement error. This is particularly pressing in fields such as evolutionary physiology, where the measurements of individual organisms may be laborious and expensive. Obtaining many measurements from many individuals from many species is difficult, and, as seen in the Oboussier neocortex-data, one often ends up with sample sizes that are small and uneven across species. In such a situation the variance attributable to measurement error can be a substantial fraction of the total, and one wants to weigh the species data according to their reliability. It is also possible that measurement variance may generate a downward bias in estimates of phylogenetic effects, because it makes species appear less statistically correlated than they are in reality. As discussed above, SLOUCH can incorporate measurement variance in both response and predictor variables.</p>
<p>For the neocortex data, estimates of measurement variance can be obtained as the square of the standard error of the species means. There is, however, a practical difficulty in that small sample sizes also makes for unreliable estimates of the measurement variance; the standard error of a species average obtained from a handful of individuals is so inaccurate as to be worthless. We therefore adopted the procedure of assuming that the within-species variance of each variable was the same for all species. The within-species variance estimated average of the sample variances of each variable was estimated as a sample-size-weighted average of the sample variances of each species; i.e. as</p>
<p><span class="math display">\[
\sigma^2_w = \frac{\sum_i \sigma_{wi}^2 (n_i - 1)}{\sum_i (n_i - 1)}
\]</span></p>
<p>where <span class="math inline">\(\sigma_{wi}^2\)</span> is the sample variance of species <span class="math inline">\(i\)</span>, and <span class="math inline">\(n_i\)</span> is the sample size of species <span class="math inline">\(i\)</span>. In this way, the larger sample sizes are weighted more. We then estimated the measurement variance of each species as <span class="math inline">\(\sigma_w^2 / n_i\)</span>. We recommend this averaging procedure to estimate measurement variance for any species mean based on a small sample of individuals.</p>
</div>
</div>
</div>
<div id="parameter-estimation-in-slouch" class="section level1">
<h1 class="hasAnchor">
<a href="#parameter-estimation-in-slouch" class="anchor"></a>Parameter estimation in SLOUCH</h1>
<div id="testing-for-phylogenetic-effects" class="section level2">
<h2 class="hasAnchor">
<a href="#testing-for-phylogenetic-effects" class="anchor"></a>Testing for phylogenetic effects</h2>
<p>The idea here is to test whether the phylogenetic relationships have an influence on the distribution of a single variable. Most phylogenetic comparative methods will begin with this step. It is important to realize, however, that phylogenetic effects are not necessarily the same thing as phylogenetic inertia. A variable can be seen to have quite strong phylogenetic effects but such a pattern can easily come about if that variable is evolving towards optima associated with niches that themselves exhibit strong phylogenetic effects. Phylogenetic inertia needs to be measured from the residuals of a model that includes predictor variables that may or may not themselves be phylogenetically structured. The way to test for an overall phylogenetic effect in the SLOUCH program is to perform a regression with no predictors (i.e. including the intercept or grand mean). To do this we use a function called <code>slouch.fit</code>. The program will estimate the phylogenetic half-life <span class="math inline">\(t_{1/2}\)</span> (<span class="math inline">\(t_{1/2} = \log(2)/\alpha\)</span>), and depending on user input, either the instantaneous variance parameter <span class="math inline">\(\sigma_y^2\)</span> or the stationary variance <span class="math inline">\(v_y\)</span> (where <span class="math inline">\(v_y = \sigma^2_y / 2 \alpha\)</span>), and the intercept (<span class="math inline">\(b_0\)</span>). The phylogenetic half-life and <span class="math inline">\(v_y\)</span> are estimated using likelihood, and there are two techniques to find the maximum likelihood estimates. The first is a grid search where we provide vectors of potential values for each parameter to the program to find the combination that maximizes the likelihood. The second is to use the built-in R optimization routines to find the best parameters. This technique uses the method “L-BFGS-B” in the <code>optim(...)</code> function to estimate parameters in the OU model, and method “Brent” when <span class="math inline">\(\alpha\)</span> is constrained to zero and the model is reduced to a Brownian motion. This technique is hereafter referred to as the “hillclimber” algorithm. The regression parameters (in this case the intercept) are estimated automatically by the program using iterated generalized least squares and are contingent on the best estimates of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(v_y\)</span>.</p>
<p>The best way to find the parameters is to start with a rough grid (i.e. values of <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span> incremented by large integer numbers) and then to “home in” on the best supported region with finer scaled grids. Some caution and “trial and error” need to be exercised here as it is possible to miss the support region entirely if the grid values are too widely spaced. There are several ways to create a vector of values in R for this purpose: </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## The manual way
h &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.01</span>, <span class="fl">0.1</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>, <span class="dv">100</span>)
vy &lt;-<span class="st"> </span>h

## Using the seq function
h &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="fl">0.001</span>, <span class="dt">to =</span> <span class="dv">100</span>, <span class="dt">length.out =</span> <span class="dv">15</span>)
vy &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="fl">0.001</span>, <span class="dt">to =</span> <span class="dv">5</span>, <span class="dt">length.out =</span> <span class="dv">15</span>)

## Using a seq function with logarithmically spaced steps
h &lt;-<span class="st"> </span><span class="kw"><a href="../reference/lseq.html">lseq</a></span>(<span class="dt">from =</span> <span class="fl">0.001</span>, <span class="dt">to =</span> <span class="dv">100</span>, <span class="dt">length.out =</span> <span class="dv">15</span>)
vy &lt;-<span class="st"> </span><span class="kw"><a href="../reference/lseq.html">lseq</a></span>(<span class="dt">from =</span> <span class="fl">0.001</span>, <span class="dt">to =</span> <span class="dv">5</span>, <span class="dt">length.out =</span> <span class="dv">15</span>)</code></pre></div>
<p> Using the default values of the model fitting function <code>slouch.fit</code>, we use an initial grid search to find the maximum likelihood estimates of <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span> in a single-optimum model, and change the grid location depending on how the surface looks. </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model0 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">hl_values =</span> <span class="kw">seq</span>(<span class="fl">0.001</span>, <span class="dv">12</span>, <span class="dt">length.out =</span> <span class="dv">10</span>),
                     <span class="dt">vy_values =</span> <span class="kw">seq</span>(<span class="fl">0.1</span>, <span class="dv">1</span>, <span class="dt">length.out =</span> <span class="dv">10</span>),
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean)
<span class="kw">plot</span>(model0)</code></pre></div>
<div class="figure">
<img src="manual_files/figure-html/unnamed-chunk-7-1.png" alt="Three-dimensional joint support region for the estimates of half-lives and stationary variances, for the single-optimum model." width="576"><p class="caption">
Three-dimensional joint support region for the estimates of half-lives and stationary variances, for the single-optimum model.
</p>
</div>
<p>The vertical axis in Figure (…) represents the log-likelihood standardized so that the maximum log-likelihood equals 0. The two horizontal axes are the vector of <code>hl_values</code> and <code>vy_values</code> that we defined in the function arguments. The peak that rises out of the flat surface therefore, represents the specific combination of <code>hl_values</code> and <code>vy_values</code> that are more than two support units below the best estimate. The flat surface itself represents parameter values falling outside the 2-unit support region (as defined by Edwars 1992). If the user prefers to plot an <span class="math inline">\(m\)</span>-unit support region, a support value of <span class="math inline">\(m\)</span> can be specified in <code>slouch.fit</code> by supplying the argument <code><a href="../reference/slouch.fit.html">slouch.fit(... ,support = m)</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">hl_values =</span> <span class="kw">seq</span>(<span class="fl">0.001</span>, <span class="dv">150</span>, <span class="dt">length.out =</span> <span class="dv">5</span>),
                     <span class="dt">vy_values =</span> <span class="kw">seq</span>(<span class="fl">0.1</span>, <span class="fl">2.5</span>, <span class="dt">length.out =</span> <span class="dv">5</span>),
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean)

<span class="kw">plot</span>(model1)</code></pre></div>
<div class="figure">
<img src="manual_files/figure-html/unnamed-chunk-8-1.png" alt="Another slice of the log likelihood surface for the same single-optimum model" width="576"><p class="caption">
Another slice of the log likelihood surface for the same single-optimum model
</p>
</div>

<p>The model objects <code>model0</code> and <code>model1</code> have a print method that displays a summary of the output (not shown). The plots of the likelihood surfaces are both based on the same data, but with different grid location and resolution. This graphical output is useful for finding and refining the support region where the aim would be to identify the upper and lower 2-unit marginal support regions for <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span>. Note that the support region is relative to the best estimate among the parameters evaluated in the entire parameter search (including parameters evaluated with the hillclimber). Thus it is essential to include the best estimate when calculating the support set. The optima and model fit statistics that are reported in the summary are conditional on the combination of these <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span> that give the highest log-likelihood; in this case the peak of the surface in the likelihood plot. If the grid-search does not contain the true maximum likelihood, the model outputs will reflect this. It is also possible to use other packages to plot the grid-search likelihood surface, for a more aesthetic look (not run).</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(plotly)
p &lt;-<span class="st"> </span><span class="kw">plot_ly</span>(<span class="dt">x =</span> model0<span class="op">$</span>supportplot<span class="op">$</span>hl,
             <span class="dt">y =</span> model0<span class="op">$</span>supportplot<span class="op">$</span>vy,
             <span class="dt">z =</span> model0<span class="op">$</span>supportplot<span class="op">$</span>z) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_surface</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">layout</span>(<span class="dt">title =</span> <span class="st">"Grid-search"</span>,
         <span class="dt">scene =</span> <span class="kw">list</span>(<span class="dt">xaxis =</span> <span class="kw">list</span>(<span class="dt">title =</span> <span class="st">"Phylogenetic half-life"</span>), 
                      <span class="dt">yaxis =</span> <span class="kw">list</span>(<span class="dt">title =</span> <span class="st">"Stationary variance"</span>),
                      <span class="dt">zaxis =</span> <span class="kw">list</span>(<span class="dt">title =</span> <span class="st">"Log-likelihood"</span>)))

p</code></pre></div>

<p>Another, perhaps more convenient way of estimating parameters is to use the hillclimber function. On default it will start on a random combination of <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(\sigma_y^2/2\alpha\)</span>, but this may also be specified. While the hillclimber might seem both faster and more accurate at first glance, there are some drawbacks. If the likelihood search space has one or more local maxima, the hillclimber may converge at a sub-optimal location and give parameter estimates that are not truly maximum-likelihood estimates. Additionally, even though the hillclimber may converge at some local or global maximum, it will not indicate whether the support region of the parameters is narrow or wide. One problem when using the hillclimber is that, depending on the specified model, the residual variance-covariance matrix <span class="math inline">\(\mathbf{V}\)</span> may collapse if <span class="math inline">\(\sigma_y^2/2\alpha\)</span> reaches zero. The immediate consequence is that matrix is non-invertible, and the program will crash. If within-species observational error is non-zero and added to the model, this does not happen. In order to use the hillclimber in this scenario, it may be necessary to constrain its search space such that <span class="math inline">\(\sigma_y^2/2\alpha\)</span> does not enter zero or close to zero. The exact feasible boundary for this may depend on the scale of the response trait.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">hillclimb =</span> <span class="ot">TRUE</span>,
                     <span class="dt">lower =</span> <span class="kw">c</span>(<span class="fl">0.001</span>, <span class="fl">0.01</span>))
<span class="kw">plot</span>(model2)</code></pre></div>
<p>The summary of <code>model2</code> can be generated by typing <code>print(model2)</code>, and displays the best estimates of all the parameters where support for the regression parameters are given as standard errors, the phylogenetically corrected <span class="math inline">\(\text{R}^2\)</span> value as the percentage of variance accounted for by the regression, and log-likelihood values as well as various information criteria for the best estimate model-fit. This output should be ignored until the grid search is deemed fine enough to accurately estimate <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span>, or if we trust that the hillclimber has converged at a global maximum.</p>
</div>
<div id="interpreting-the-parameters" class="section level2">
<h2 class="hasAnchor">
<a href="#interpreting-the-parameters" class="anchor"></a>Interpreting the parameters</h2>
<p>The phylogenetic half-life parameter (<span class="math inline">\(t_{1/2} = \log(2) / \alpha\)</span>) measures the influence of the ancestral state of the variable in question relative to the tendency to evolve towards the common ancestral state (the intercept). Conversely, <span class="math inline">\(\alpha\)</span> measures the rate of adaptation. If the best estimate of <span class="math inline">\(t_{1/2}\)</span> is 0, the ancestral state does not influence the current state of the variable. The larger <span class="math inline">\(t_{1/2}\)</span> gets, the more influence the past state of the variable has on its current state (i.e. the trait‘s evolution approaches a Brownian motion as <span class="math inline">\(t_{1/2}\)</span> approaches infinity). The units of the phylogenetic half-lives are the same units as the branch lengths in the phylogenetic tree, <code>phy$edge.length</code>. The total depth, or distance from the root, can for all nodes be calculated with <code><a href="http://www.rdocumentation.org/packages/ape/topics/node.depth">node.depth.edgelength(phy)</a></code>. For this phylogenetic tree the maximum tree depth is about 27 million years. The phylogenetic correction factor is another measure of the strength of inertia:</p>
<p><span class="math display">\[
\rho(\alpha, t) = (1 - \frac{(1 - e^{-\alpha t})}{(\alpha t)})
\]</span></p>
<p>It can range anywhere between 0 and 1 where the closer to 0 it is, the stronger the inertia. The intercept-only model is also useful for testing one of the assumptions of the OU-BM model; that the predictor variables evolve as a Brownian motion. The stationary variance (<span class="math inline">\(v_y = \sigma^2_y / 2\alpha\)</span>) of the joint OU-BM process is a measure of the relative influence of stochastic factors in the adaptive process relative to the primary adaptive force. Secondary stochasticity is generated by a combination of stochastic influences (such as changes in unmeasured selective forces, genetic drift, etc) on the response variable as it evolves towards the optimum or optima.</p>
</div>
</div>
<div id="adding-predictors-and-testing-for-phylogenetic-inertia" class="section level1">
<h1 class="hasAnchor">
<a href="#adding-predictors-and-testing-for-phylogenetic-inertia" class="anchor"></a>Adding predictors and testing for phylogenetic inertia</h1>
<div id="continuous-random-predictor" class="section level2">
<h2 class="hasAnchor">
<a href="#continuous-random-predictor" class="anchor"></a>Continuous random predictor</h2>
<p>The parameters we estimate for the models that have a single random predictor variable are: <span class="math inline">\(t_{1/2}\)</span> (and therefore <span class="math inline">\(\alpha\)</span>), <span class="math inline">\(\sigma_x^2\)</span>, <span class="math inline">\(v_y\)</span>, and the regression parameters <span class="math inline">\(b_i\)</span>. Recall that the regression parameters <span class="math inline">\(b_i\)</span> can be given in one of two ways, as an evolutionary regression or as an optimal regression where the latter is “corrected” by the phylogenetic correction factor. The predictor variance, <span class="math inline">\(\sigma_x^2\)</span>, is estimated a priori by SLOUCH. Once again we use the <code>slouch.fit</code> function except that this time we add in the predictor variable (and its measurement variance). The estimation procedure itself is performed in a similar manner as for the intercept-only models above. For example, if we wanted to perform a regression of log neocortex size (<span class="math inline">\(\text{mm}^2\)</span>) on log brain mass (g), we would type:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">braincentered &lt;-<span class="st"> </span>neocortex<span class="op">$</span>brain_mass_g_log_mean <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(neocortex<span class="op">$</span>brain_mass_g_log_mean)
model3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                     <span class="dt">random.cov =</span> braincentered,
                     <span class="dt">mv.random.cov =</span> neocortex<span class="op">$</span>brain_se_squared,
                     <span class="dt">lower =</span> <span class="kw">c</span>(<span class="fl">0.001</span>, <span class="fl">0.01</span>),
                     <span class="dt">hillclimb =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(model3)</code></pre></div>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="dt">x =</span> braincentered, 
     <span class="dt">y =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean, 
     <span class="dt">xlab =</span> <span class="st">"Mean log brain mass (g)"</span>,
     <span class="dt">ylab =</span> <span class="st">"Mean log neocortex area (mm2)"</span>)
<span class="kw">abline</span>(model3<span class="op">$</span>ev.reg<span class="op">$</span>coefficients_bias_corr[,<span class="dv">1</span>], 
       <span class="dt">col =</span> <span class="st">"black"</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)
<span class="kw">abline</span>(model3<span class="op">$</span>opt.reg<span class="op">$</span>coefficients_bias_corr[,<span class="dv">1</span>], 
       <span class="dt">col =</span> <span class="st">"orange"</span>, <span class="dt">lwd =</span> <span class="dv">2</span>)</code></pre></div>
<div class="figure">
<img src="manual_files/figure-html/unnamed-chunk-12-1.png" alt="The evolutionary (black) and optimal (orange) regression lines for the model of mean log neocortex area (mm$^2$) on mean log brain mass (g), both corrected for bias due to measurement error in mean log brain mass." width="672"><p class="caption">
The evolutionary (black) and optimal (orange) regression lines for the model of mean log neocortex area (mm<span class="math inline">\(^2\)</span>) on mean log brain mass (g), both corrected for bias due to measurement error in mean log brain mass.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model3<span class="op">$</span>opt.reg<span class="op">$</span>coefficients</code></pre></div>
<pre><code>##                    Estimates Std. error
## (Intercept)         9.668006 0.03718931
## braincentered (bm)  0.919889 0.03892640</code></pre>
<p>While the single-optimum model showed a very strong phylogenetic signal, this model exhibits much less phylogenetic inertia, with best estimate of the phylogenetic half-life (<span class="math inline">\(t_{1/2}\)</span>) being 1 myr. Here, the optimal regression is steeper than the evolutionary regression. It is also possible to fit a model with multiple continuous covariates, however the input to <code>random.cov</code> must be a matrix or data frame that has column names, and the observational error passed to <code>mv.random.cov</code> must be a matrix or data frame of the same shape as <code>random.cov</code>.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bodycentered &lt;-<span class="st"> </span>neocortex<span class="op">$</span>body_mass_g_log_mean <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(neocortex<span class="op">$</span>body_mass_g_log_mean)
model4 &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
             <span class="dt">species =</span> neocortex<span class="op">$</span>species,
             <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
             <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
             <span class="dt">random.cov =</span> <span class="kw">cbind</span>(braincentered, 
                                bodycentered),
             <span class="dt">mv.random.cov =</span> <span class="kw">cbind</span>(neocortex<span class="op">$</span>brain_se_squared,
                                   neocortex<span class="op">$</span>body_se_squared),
             <span class="dt">lower =</span> <span class="kw">c</span>(<span class="fl">0.001</span>, <span class="fl">0.01</span>),
             <span class="dt">hillclimb =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(model4)</code></pre></div>
</div>
<div id="estimation-error-and-model-support" class="section level2">
<h2 class="hasAnchor">
<a href="#estimation-error-and-model-support" class="anchor"></a>Estimation error and model support</h2>
<p>The type of estimation error (i.e. log-likelihood units or standard errors) reported in the SLOUCH 2.0 output depends on the statistical technique used to obtain a particular parameter (maximum likelihood or GLS). The parameters <span class="math inline">\(\alpha\)</span> (and its relatives, <span class="math inline">\(t_{1/2}\)</span> and the phylogentic correction factor, <span class="math inline">\(\rho\)</span>) and <span class="math inline">\(v_y\)</span> are estimated with maximum likelihood. Note that in the 2-unit support region surface plot we plot <span class="math inline">\(t_{1/2}\)</span> against <span class="math inline">\(v_y\)</span>, rather than <span class="math inline">\(\alpha\)</span>. The reason for this is that <span class="math inline">\(t_{1/2}\)</span> is easier to interpret as a measure of phylogenetic inertia as it can be interpreted on the same linear scale as the branch lengths (and this is also the reason we provide a vector of half life values rather than <span class="math inline">\(\alpha\)</span> values during the grid search). The best estimates of <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span> are however a joint estimate and for this reason the support region (the three-dimensional log-likelihood plot) is given as a measure of uncertainty for <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span> jointly. The number of potential <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span> values to include in the support region is, as mentioned previously, defined by the user (where by default, this is all estimates that give greater than maximum support - 2 support units). The marginal lowest and highest values of <span class="math inline">\(t_{1/2}\)</span> within the support region, conditional on the best estimate of <span class="math inline">\(v_y\)</span>, can also be obtained using the figure and the support-region tables in the output (and vice versa for <span class="math inline">\(v_y\)</span>). The <code>slouch.fit</code> function can also take scalars rather than vectors, which may be useful for finding the marginal support region of <span class="math inline">\(t_{1/2}\)</span> conditional on <span class="math inline">\(v_y\)</span> (and vice versa). In this case the 2-unit support region is no longer plotted, however the support limits can still be derived using the model summary or by looking at the elements of the model object. The regression parameters are estimated using iterated GLS and their estimation errors are given as standard errors, which can then be used to construct confidence intervals. Along with the <span class="math inline">\(b_i\)</span> estimates themselves, SLOUCH output provides the phylogenetically-corrected <span class="math inline">\(\text{R}^2\)</span> value as the percentage variance accounted for by the regression. The “goodness of fit” of the model itself to a particular data set is given as the support (logL) where a higher value means a better fit. In addition, SLOUCH provides three information criteria for model evaluation: AIC, AICc and the stricter SIC (also called the BIC). Which one to use is up to the user but we recommend the small sample size AIC (AICc, see Burnham &amp; Anderson, 1998). For the information criteria, smaller values mean a better model fit. These values can be compared across models that use different predictor variables, different number of predictors, different types of predictor variable (e.g. categorical vs. continuous), or different models of evolution (Ornstein-Uhlenbeck vs. Brownian motion). Note that all of the model fit statistics, as well as the parameter search itself, is conditional on the <em>naive</em> GLS estimator, i.e. prior to any bias-correction routines.</p>
</div>
<div id="estimating-the-intercept" class="section level2">
<h2 class="hasAnchor">
<a href="#estimating-the-intercept" class="anchor"></a>Estimating the intercept</h2>
<p>The <code>slouch.fit</code> function will on default estimate the intercept <span class="math inline">\(k\)</span>. If the phylogenetic tree is non-ultrametric, for example due to the inclusion of extinct species, it is possible to estimate the components of <span class="math inline">\(k\)</span>. Recall that, when <span class="math inline">\(y\)</span> is evolving according to an Ornstein-Uhlenbeck process in response to one or more predictors <span class="math inline">\(x\)</span> evolving as Brownian motions, the intercept <span class="math inline">\(k\)</span> is</p>
<p><span class="math display">\[
k = e^{-\alpha t}y_a + (1 - e^{- \alpha t})b_0 + (1 - e^{-\alpha t} - \rho(\alpha t))(b_1x_{a1} + b_2x_{a2} + \dots)
\]</span></p>
<p>SLOUCH can independently estimate <span class="math inline">\(y_a\)</span>, <span class="math inline">\(b_0\)</span> and the sum <span class="math inline">\(bx_a = (b_1x_{a1} + b_2x_{a2} + \dots)\)</span>. Using the same example with neocortex evolving in response to brain size, we would specify:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model5 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                     <span class="dt">random.cov =</span> braincentered,
                     <span class="dt">mv.random.cov =</span> neocortex<span class="op">$</span>brain_se_squared,
                     <span class="dt">lower =</span> <span class="kw">c</span>(<span class="fl">0.001</span>, <span class="fl">0.01</span>),
                     <span class="dt">estimate.Ya =</span> T,
                     <span class="dt">estimate.bXa =</span> T,
                     <span class="dt">hillclimb =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>The parameters <span class="math inline">\(y_a\)</span> and <span class="math inline">\(bx_a\)</span> represent the ancestral states for <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> separate from the regression intercept <span class="math inline">\(b_0\)</span>. Since this phylogenetic tree is ultrametric, we cannot recover independent estimates of these. If we would try to execute the above code, we would not be able to estimate the GLS coefficients since the model matrix becomes singular. Even if we had a non-ultrametric tree, the intercept components are often estimated with extremely low power, so it can make sense to estimate them as a combined intercept term. This is done by default, or by specifying <code><a href="../reference/slouch.fit.html">slouch.fit(..., estimate.Ya = FALSE, estimate.bXa = FALSE)</a></code> in the function call. The phylogenetic residual covariance matrix will always be computed based on the phylogenetic tree, whether it is ultrametric or not. In some cases (for example, when inertia is small), estimating the components of <span class="math inline">\(k\)</span> will not work (due mainly to numerical issues because of unstable coefficient and parameter combinations in the intercept terms and non-convergence of regression parameters). Also note that, in the non-ultrametric case, each species theoretically has its own optimal intercept (<span class="math inline">\(b_0\)</span>), however the reported estimate is actually an average of these. Its primary purpose is to allow us to plot a regression line.</p>
</div>
<div id="multiple-optima-phylo-format" class="section level2">
<h2 class="hasAnchor">
<a href="#multiple-optima-phylo-format" class="anchor"></a>Multiple optima &amp; phylo-format</h2>
<p>SLOUCH can fit models with multiple adaptive regimes or niches over the branches of the phylogenetic tree. We will fit neocortex size as a function of diet in artiodactyls. Trees in the <code>phylo</code> format are represented by the edges found in <code>phy$edge</code>, where each edge connects two vertices or nodes. All of the tip nodes have indices starting from 1, 2, 3 … until <span class="math inline">\(n_{tips}\)</span>, in this case 43. The root node has index <span class="math inline">\(n_{tips}\)</span>+1, here 44, and the rest of the internal nodes have indices (<span class="math inline">\(n_{tips}\)</span>+2, <span class="math inline">\(n_{tips}\)</span>+3, …, <span class="math inline">\(n_{nodes}\)</span>). When running this type of model, we will need to specify the internal adaptive regimes in the order of node indices (<span class="math inline">\(n_{tips}\)</span>+1, <span class="math inline">\(n_{tips}\)</span>+2, <span class="math inline">\(n_{tips}\)</span>+3, …, <span class="math inline">\(n_{nodes}\)</span>). The regimes for the tips must be supplied to the <code>fixed.fact</code> argument (<code><a href="../reference/slouch.fit.html">slouch.fit(..., fixed.fact = neocortex$diet)</a></code>), and the regimes for the internal nodes must be assigned to <code>phy$node.label</code>. In order to plot and visually verify that the ancestral state configuration is sensible, we need to have all the regimes in the order of the <strong>edges</strong>, not the nodes. </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Inspect the internal node regimes
## These have order n+1, n+2, n+3 ...
internal_regimes &lt;-<span class="st"> </span><span class="kw">factor</span>(phy<span class="op">$</span>node.label)

## Concatenate tip and internal regimes. These will have order 1,2,3 ...
regimes &lt;-<span class="st"> </span><span class="kw">c</span>(neocortex<span class="op">$</span>diet, internal_regimes)

## Pick out the regimes of the edges, in the order of phy$edge
edge_regimes &lt;-<span class="st"> </span><span class="kw">factor</span>(regimes[phy<span class="op">$</span>edge[,<span class="dv">2</span>]])

<span class="kw">plot</span>(phy, 
     <span class="dt">edge.color =</span> <span class="kw">c</span>(<span class="st">"Black"</span>, <span class="st">"Orange"</span>, <span class="st">"blue"</span>)[edge_regimes], 
     <span class="dt">edge.width =</span> <span class="dv">3</span>, <span class="dt">cex =</span> <span class="fl">0.6</span>)</code></pre></div>
<p><img src="manual_files/figure-html/unnamed-chunk-16-1.png" width="672"></p>
<p> If it looks like there are no visible mistakes, we can go ahead and fit the model in SLOUCH.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model6 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">direct.cov =</span> neocortex<span class="op">$</span>brain_mass_g_log_mean,
                     <span class="dt">fixed.fact =</span> neocortex<span class="op">$</span>diet,
                     <span class="dt">hillclimb =</span> <span class="ot">TRUE</span>,
                     <span class="dt">lower =</span> <span class="kw">c</span>(<span class="fl">0.001</span>, <span class="fl">0.01</span>))

model6<span class="op">$</span>opt.reg<span class="op">$</span>coefficients</code></pre></div>
<pre><code>##                                 Estimates Std. error
## Br                              5.3746627 0.22276581
## Gr                              5.6045135 0.30280314
## MF                              5.5558922 0.22390136
## neocortex$brain_mass_g_log_mean 0.8203544 0.04314244</code></pre>
</div>
<div id="direct-effect-predictors" class="section level2">
<h2 class="hasAnchor">
<a href="#direct-effect-predictors" class="anchor"></a>Direct effect predictors</h2>
<p>SLOUCH can also fit models with continuous covariates that don’t have any phylogenetic covariance structure, variables that influence the optimum directly and immediately. Here, both the grid-search and the hillclimber routine are used to find the maximum-likelihood estimates for <span class="math inline">\(t_{1/2}\)</span> and <span class="math inline">\(v_y\)</span>.</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model7 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/slouch.fit.html">slouch.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">hl_values =</span> <span class="kw">seq</span>(<span class="fl">0.001</span>, <span class="dv">5</span>, <span class="dt">length.out =</span> <span class="dv">5</span>),
                     <span class="dt">vy_values =</span> <span class="kw">seq</span>(<span class="fl">0.001</span>, <span class="fl">0.05</span>, <span class="dt">length.out =</span> <span class="dv">5</span>),
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                     <span class="dt">direct.cov =</span> neocortex<span class="op">$</span>brain_mass_g_log_mean,
                     <span class="dt">mv.direct.cov =</span> neocortex<span class="op">$</span>brain_se_squared,
                     <span class="dt">hillclimb =</span> <span class="ot">TRUE</span>,
                     <span class="dt">lower =</span> <span class="kw">c</span>(<span class="fl">0.001</span>, <span class="fl">0.0005</span>))

model7<span class="op">$</span>opt.reg<span class="op">$</span>coefficients</code></pre></div>
<pre><code>##                                 Estimates Std. error
## (Intercept)                     5.4052790 0.24164087
## neocortex$brain_mass_g_log_mean 0.8463384 0.04311938</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(model7)</code></pre></div>
<p><img src="manual_files/figure-html/unnamed-chunk-19-1.png" width="672"></p>
</div>
</div>
<div id="brownian-motion-models" class="section level1">
<h1 class="hasAnchor">
<a href="#brownian-motion-models" class="anchor"></a>Brownian-motion models</h1>
<p>Until this point we have only looked at Ornstein-Uhlenbeck models of trait evolution. When <span class="math inline">\(\alpha = 0\)</span>, however, the model collapses into a Brownian motion with no pull towards the optimum and this is the case when the best estimate of the phylogenetic half-life is much larger than the tree depth (<span class="math inline">\(t_{1/2} &gt;&gt; t\)</span>). The <code><a href="../reference/brown.fit.html">brown.fit()</a></code> function can fit the same kinds of models that <code><a href="../reference/slouch.fit.html">slouch.fit()</a></code> does, except under a Brownian motion model of evolution. The stochastic differential equation is</p>
<p><span class="math display">\[
dy = \sigma_y dW_y
\]</span></p>
<p>where <span class="math inline">\(dW_y \sim N(0, dt)\)</span>. The residual covariance is <span class="math inline">\(\text{Cov}[r_i, r_j] = \sigma_y^2t_a\)</span>, where <span class="math inline">\(t_a\)</span> is the sum of shared branch lengths for species <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>. With this model, we only estimate one parameter with likelihood: <span class="math inline">\(\sigma_y^2\)</span>, which in this example has units <span class="math inline">\((\log(\text{neocortex(mm}^2)))^2 \times \text{myr}^{-1}\)</span>. The parameters <span class="math inline">\(v_y = \sigma_y^2/2\alpha\)</span> and <span class="math inline">\(t_{1/2}\)</span> no longer enter the equation. The intercept-only model can be fitted by entering the following: </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model8 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/brown.fit.html">brown.fit</a></span>(<span class="dt">phy =</span> phy,
                    <span class="dt">sigma2_y_values =</span> <span class="kw">seq</span>(<span class="fl">0.008</span>, <span class="fl">0.05</span>, <span class="dt">length.out =</span> <span class="dv">80</span>),
                    <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                    <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                    <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                    <span class="dt">hillclimb =</span> <span class="ot">TRUE</span>,
                    <span class="dt">lower =</span> <span class="fl">0.0005</span>)

model8<span class="op">$</span>opt.reg<span class="op">$</span>coefficients</code></pre></div>
<pre><code>##             Estimates Std. error
## (Intercept)   9.75765  0.3670418</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(model8)</code></pre></div>
<p><img src="manual_files/figure-html/unnamed-chunk-20-1.png" width="672"></p>
<p>Keep in mind that, since there is no directional or stabilizing trend in a standard Brownian motion, the intercept is the same as the ancestral state <span class="math inline">\(y_a\)</span>. Unlike the OU process, there are no optima (<span class="math inline">\(\theta\)</span>), and the rate of adaptation (<span class="math inline">\(\alpha\)</span>) is not a part of the model. We can, however, expand the model to include regime-dependent trends:</p>
<p><span class="math display">\[
dy = \tau dt + \sigma_y dW_y
\]</span></p>
<p>where <span class="math inline">\(\tau\)</span> is one or more trends. The trends (<span class="math inline">\(\tau\)</span>) in this model are equivalent to <span class="math inline">\(\tau = \lim_{\alpha \to 0}(\theta\alpha)\)</span> under an OU model. The expected value of the trait is <span class="math display">\[
\text{E}[y_i](t) = y_a + \sum_s{\tau_s t_s}
\]</span> where <span class="math inline">\(t_s\)</span> is the total time that species <span class="math inline">\(i\)</span> has spent in regime <span class="math inline">\(s\)</span>. With ultrametric trees, <span class="math inline">\(y_a\)</span> can not be estimated independently of the trends <span class="math inline">\(\tau\)</span>, and as such <span class="math inline">\(y_a\)</span> is not estimated with default settings. In other words, we assume that <span class="math inline">\(y_a = 0\)</span>, and hence the trends <span class="math inline">\(\tau_s\)</span> can only be interpreted relative to each other. If we do estimate <span class="math inline">\(y_a\)</span> independently, however, the trends <span class="math inline">\(\tau_s\)</span> will represent the absolute expected direction of change. We will fit log neocortex area with different trends for each dietary regime:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model9 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/brown.fit.html">brown.fit</a></span>(<span class="dt">phy =</span> phy,
                    <span class="dt">sigma2_y_values =</span> <span class="kw">seq</span>(<span class="fl">0.008</span>, <span class="fl">0.05</span>, <span class="dt">length.out =</span> <span class="dv">80</span>),
                    <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                    <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                    <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                    <span class="dt">fixed.fact =</span> neocortex<span class="op">$</span>diet,
                    <span class="dt">hillclimb =</span> <span class="ot">TRUE</span>,
                    <span class="dt">lower =</span> <span class="fl">0.0005</span>)

<span class="kw">plot</span>(model9)</code></pre></div>
<p><img src="manual_files/figure-html/unnamed-chunk-21-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model9<span class="op">$</span>opt.reg<span class="op">$</span>coefficients</code></pre></div>
<pre><code>##            Estimates Std. error
## Br (trend) 0.3417555 0.01629202
## Gr (trend) 0.4078647 0.02633825
## MF (trend) 0.3647233 0.01388005</code></pre>
<p>In this example, the trends (<span class="math inline">\(\tau\)</span>) are in units of <span class="math inline">\(\log \text{neocortex} (\text{mm}^2) \times \text{myr}^{-1}\)</span>. Since with this procedure we assume that <span class="math inline">\(y_a = 0\)</span>, we can only interpret the relative differences among the trends.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model9<span class="op">$</span>opt.reg<span class="op">$</span>trend_diff</code></pre></div>
<pre><code>##                            Contrast Std. error
## Gr (trend) - Br (trend)  0.06610920 0.02665333
## MF (trend) - Br (trend)  0.02296778 0.01602782
## MF (trend) - Gr (trend) -0.04314142 0.02478017</code></pre>
<p>By looking at the pairwise contrasts, we can see that the expected increase in neocortex for grazers is larger than for browsers and mixed feeders.</p>
<div id="continuous-covariates" class="section level2">
<h2 class="hasAnchor">
<a href="#continuous-covariates" class="anchor"></a>Continuous covariates</h2>
<p>Next, we can expand the model to include continuous covariates. If we model the covariates to influence the response trait directly and immediately, the implementation is much the same as in the previous example, with <code><a href="../reference/brown.fit.html">brown.fit(..., direct.cov = x)</a></code>. Another option is to model the trend as a linear function of a random variable evolving as a Brownian motion (<span class="math inline">\(\tau = a + bx\)</span>).</p>
<p><span class="math display">\[
dy = (a + bx)dt + \sigma_y dW_y
\]</span> <span class="math display">\[
dx = \sigma_x dW_x
\]</span> where <span class="math inline">\(a\)</span> are the regime-dependent trends as previously denoted <span class="math inline">\(\tau\)</span>, and <span class="math inline">\(x\)</span> is a random variable evolving as a Brownian motion. In the case of multiple independent predictors, we have <span class="math display">\[
dy = (a + \sum_k{b_kx_k})dt + \sigma_y dW_y
\]</span> where <span class="math inline">\(\sum_k{b_kx_k}\)</span> is also a Brownian motion with variances <span class="math inline">\(\sigma_\theta^2 = \sum_k{b_k^2 \sigma_k^2}\)</span>. The residual covariance for this model is</p>
<p><span class="math display">\[
\text{Cov}[r_i, r_j] = \sigma_y^2 t_a + \sigma_\theta^2 t_a(t_a^2/12 + t_{ia}t_{ja}/4)
\]</span></p>
<p>where the time from the most recent common ancestor (MRCA) of species <span class="math inline">\(i, j\)</span> to species <span class="math inline">\(i\)</span> is <span class="math inline">\(t_{ia}\)</span>, and the time from the MRCA to species <span class="math inline">\(j\)</span> is <span class="math inline">\(t_{ja}\)</span>. To fit such a model of log neocortex area on log brain mass, we would enter:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model10 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/brown.fit.html">brown.fit</a></span>(<span class="dt">phy =</span> phy,
                     <span class="dt">sigma2_y_values =</span> <span class="kw">seq</span>(<span class="fl">0.00001</span>, <span class="fl">0.002</span>, <span class="dt">length.out =</span> <span class="dv">80</span>),
                     <span class="dt">species =</span> neocortex<span class="op">$</span>species,
                     <span class="dt">response =</span> neocortex<span class="op">$</span>neocortex_area_mm2_log_mean,
                     <span class="dt">mv.response =</span> neocortex<span class="op">$</span>neocortex_se_squared,
                     <span class="dt">random.cov =</span> braincentered,
                     <span class="dt">mv.random.cov =</span> neocortex<span class="op">$</span>brain_se_squared,
                     <span class="dt">fixed.fact =</span> neocortex<span class="op">$</span>diet,
                     <span class="dt">hillclimb =</span> <span class="ot">TRUE</span>,
                     <span class="dt">lower =</span> <span class="fl">0.000000001</span>)

model10<span class="op">$</span>opt.reg<span class="op">$</span>coefficients</code></pre></div>
<pre><code>##                            Estimates  Std. error
## Br (trend)                0.35058109 0.010751746
## Gr (trend)                0.35883452 0.016790619
## MF (trend)                0.35982616 0.009280627
## braincentered (bm, trend) 0.06239518 0.006167110</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(model10)</code></pre></div>
<p><img src="manual_files/figure-html/unnamed-chunk-23-1.png" width="672"></p>
<p><strong>Comment</strong>: The brownian-motion section is a little thin. We can’t just cite thomas’ &amp; krzysztof’s notes for the interpretation and derivation, can we? Does this kind of material even fit in a manual, if not first introduced elsewhere?</p>

</div>
</div>
<div id="references" class="section level1">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<p>Burnham, K. P. &amp; Anderson, D. R. (1998). Model selection and inference: A practical information- theoretic approach. Springer.</p>
<p>Butler, M. A., &amp; King, A. A. (2004). Phylogenetic comparative analysis: a modeling approach for adaptive evolution. American Naturalist, 164(6), 683–695. <a href="https://doi.org/10.1086/426002" class="uri">https://doi.org/10.1086/426002</a></p>
<p>Edwards, A. W. F. (1992). Likelihood. expanded edition Johns Hopkins University Press. Baltimore, MD.</p>
<p>Escudero, M., Hipp, A. L., Hansen, T. F., Voje, K. L., &amp; Luceño, M. (2012). Selection and inertia in the evolution of holocentric chromosomes in sedges (Carex, Cyperaceae). New Phytologist, 195(1), 237–247. <a href="https://doi.org/10.1111/j.1469-8137.2012.04137.x" class="uri">https://doi.org/10.1111/j.1469-8137.2012.04137.x</a></p>
<p>Hansen, T. F. (1997). Stabilizing Selection and the Comparative Analysis of Adaptation. Evolution, 51(5), 1341. <a href="https://doi.org/10.2307/2411186" class="uri">https://doi.org/10.2307/2411186</a></p>
<p>Hansen, T. F., &amp; Martins, E. P. (1996). Translating between microevolutionary process and macroevolutionary patterns: the correlation structure of interspecific data. Evolution, 50(4), 1404-1417.</p>
<p>Hansen, T. F., &amp; Orzack, S. H. (2005). Assessing current adaptation and phylogenetic inertia as explanations of trait evolution: the need for controlled comparisons. Evolution, 59(10), 2063-2072.</p>
<p>Hansen, T. F., Pienaar, J., &amp; Orzack, S. H. (2008). A comparative method for studying adaptation to a randomly evolving environment. Evolution, 62(8), 1965–1977. <a href="https://doi.org/10.1111/j.1558-5646.2008.00412.x" class="uri">https://doi.org/10.1111/j.1558-5646.2008.00412.x</a></p>
<p>Hansen, T. F., &amp; Bartoszek, K. (2012). Interpreting the evolutionary regression: The interplay between observational and biological errors in phylogenetic comparative studies. Systematic Biology, 61(3), 413–425. <a href="https://doi.org/10.1093/sysbio/syr122" class="uri">https://doi.org/10.1093/sysbio/syr122</a></p>
<p>Hansen, T. F. (2014). Use and misuse of comparative methods in the study of adaptation. In Garamszegi &amp; L. Zsolt (Eds.), Modern Phylogenetic Comparative Methods and their Application in Evolutionary Biology (pp. 351–379). Springer. <a href="https://doi.org/10.1007/978-3-662-43550-2_14" class="uri">https://doi.org/10.1007/978-3-662-43550-2_14</a></p>
<p>Harvey, P. H., &amp; Pagel, M. D. (1991). The comparative method in evolutionary biology (Vol. 239). Oxford: Oxford university press.</p>
<p>Martins, E. P., &amp; Hansen, T. F. (1997). Phylogenies and the comparative method: a general approach to incorporating phylogenetic information into the analysis of interspecific data. The American Naturalist, 149(4), 646-667.</p>
<p>O’Meara, B. C., &amp; Beaulieu, J. M. (2014). Modelling stabilizing selection: The attraction of Ornstein-Uhlenbeck models. In Garamszegi &amp; L. Zsolt (Eds.), Modern Phylogenetic Comparative Methods and their Application in Evolutionary Biology (pp. 381–393). Springer. <a href="https://doi.org/10.1007/978-3-662-43550-2_15" class="uri">https://doi.org/10.1007/978-3-662-43550-2_15</a></p>
<p>Labra, A., Pienaar, J., &amp; Hansen, T. F. (2009). Evolution of Thermal Physiology in Liolaemus Lizards: Adaptation, Phylogenetic Inertia, and Niche Tracking. The American Naturalist, 174(2), 204–220. <a href="https://doi.org/10.1086/600088" class="uri">https://doi.org/10.1086/600088</a></p>
<p>Ridley, M. (1983). The explanation of organic diversity: the comparative method and adaptations for mating. Oxford University Press, USA.</p>
<p>Toljagić, O., Voje, K. L., Matschiner, M., Liow, L. H., &amp; Hansen, T. F. (2017). Millions of years behind: Slow adaptation of ruminants to grasslands. Systematic Biology, (318). <a href="https://doi.org/10.1093/sysbio/syx059" class="uri">https://doi.org/10.1093/sysbio/syx059</a></p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#overview">Overview</a></li>
      <li>
<a href="#comparative-methods-for-adaptive-hypotheses">Comparative methods for adaptive hypotheses</a><ul class="nav nav-pills nav-stacked">
<li><a href="#background">Background</a></li>
      <li><a href="#comparative-methods-built-around-an-ornstein-uhlenbeck-process">Comparative methods built around an Ornstein-Uhlenbeck process</a></li>
      <li><a href="#estimation-specifics">Estimation specifics</a></li>
      <li><a href="#model-selection">Model selection</a></li>
      <li><a href="#measurement-variance">Measurement variance</a></li>
      <li><a href="#caveats-and-limitations">Caveats and limitations</a></li>
      </ul>
</li>
      <li>
<a href="#data-requirements">Data requirements</a><ul class="nav nav-pills nav-stacked">
<li><a href="#checklist">Checklist</a></li>
      <li><a href="#installing-slouch-and-loading-the-tree">Installing SLOUCH and loading the tree</a></li>
      </ul>
</li>
      <li>
<a href="#parameter-estimation-in-slouch">Parameter estimation in SLOUCH</a><ul class="nav nav-pills nav-stacked">
<li><a href="#testing-for-phylogenetic-effects">Testing for phylogenetic effects</a></li>
      <li><a href="#interpreting-the-parameters">Interpreting the parameters</a></li>
      </ul>
</li>
      <li>
<a href="#adding-predictors-and-testing-for-phylogenetic-inertia">Adding predictors and testing for phylogenetic inertia</a><ul class="nav nav-pills nav-stacked">
<li><a href="#continuous-random-predictor">Continuous random predictor</a></li>
      <li><a href="#estimation-error-and-model-support">Estimation error and model support</a></li>
      <li><a href="#estimating-the-intercept">Estimating the intercept</a></li>
      <li><a href="#multiple-optima-phylo-format">Multiple optima &amp; phylo-format</a></li>
      <li><a href="#direct-effect-predictors">Direct effect predictors</a></li>
      </ul>
</li>
      <li>
<a href="#brownian-motion-models">Brownian-motion models</a><ul class="nav nav-pills nav-stacked">
<li><a href="#continuous-covariates">Continuous covariates</a></li>
      </ul>
</li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Bjørn Tore Kopperud, Jason Pienaar, Kjetil Lysne Voje, Steven Hecht Orzack, Thomas F. Hansen.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
