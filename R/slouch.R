#'SLOUCH: Stochastic Linear Ornstein Uhlenbeck Comparative Hypotheses
#'
#'
"_PACKAGE"



#' Title
#'
#' @param topology
#' @param times
#' @param half_life_values
#' @param vy_values
#' @param response
#' @param me.response
#' @param fixed.fact
#' @param fixed.cov
#' @param me.fixed.cov
#' @param mecov.fixed.cov
#' @param random.cov
#' @param me.random.cov
#' @param mecov.random.cov
#' @param intercept
#' @param ultrametric
#' @param support
#' @param convergence
#' @param plot.angle
#'
#' @return
#' @examples
#' @export
#'

model.fit.dev<-function(topology, times, half_life_values, vy_values, response, me.response=NULL, fixed.fact=NULL,fixed.cov=NULL, me.fixed.cov=NULL, mecov.fixed.cov=NULL, random.cov=NULL, me.random.cov=NULL, mecov.random.cov=NULL,  intercept="root", ultrametric=TRUE, support=NULL, convergence=NULL, plot.angle=30, parallel.compute = FALSE)
{
  ancestor <- topology
  # SET DEFAULTS IF NOT SPECIFIED
  
  if(is.null(support)) support <- 2
  if(is.null(convergence)) convergence <- 0.000001
  if(is.null(me.response)){
    me.response<-diag(rep(0, times=length(response[!is.na(response)])))
  }else{
    me.response<-diag(me.response[!is.na(me.response)])
  }
  
  
  # DETERMINE MODEL STRUCTURE FROM INPUT AND WRITE A SUMMARY TO THE R CONSOLE
  
  if(is.null(fixed.fact) && is.null(fixed.cov) && is.null(random.cov)) model.type <- "IntcptReg";
  if(!is.null(fixed.fact) && is.null(fixed.cov) && is.null(random.cov)) model.type <- "ffANOVA";
  if(!is.null(fixed.fact) && !is.null(fixed.cov) && is.null(random.cov)) model.type <-"ffANCOVA";
  if(!is.null(fixed.fact) && is.null(fixed.cov) && !is.null(random.cov)) model.type <- "mmANCOVA";
  if(!is.null(fixed.fact) && !is.null(fixed.cov) && !is.null(random.cov)) model.type <- "mmfANCOVA";
  if(is.null(fixed.fact) && is.null(fixed.cov) && !is.null(random.cov)) model.type <- "rReg";
  if(is.null(fixed.fact) && !is.null(fixed.cov) && is.null(random.cov)) model.type <- "fReg";
  if(is.null(fixed.fact) && !is.null(fixed.cov) && !is.null(random.cov)) model.type <- "mfReg";
  
  # Write type of model to screen
  message("")
  message("MODEL SUMMARY")
  message("")
  if(model.type=="IntcptReg")
  {
    message("You have specified an OU model for a response variable regressed on a grand mean, i.e. one global optima");
    if(ultrametric==FALSE)
    {
      GS_head<-c("Ya", "Theta_Global")
      #n.par<-2 # Bjorn: unused?
    }
    else
    {
      GS_head<-("Theta_Global")
      #n.par<-1 # Bjorn: unused?
    }
  }
  else
    if(model.type=="ffANOVA" )
    {
      message("You have specified an OU model for a response variable modeled on optima determined by fixed, categorical predictor variables");
      if(is.null(intercept)) GS_head<-c("Ya", levels(as.factor(fixed.fact))) else GS_head<-levels(as.factor(fixed.fact));
    }
  
  else
    if(model.type=="ffANCOVA")
    {
      message("You have specified an OU model for a response variable modeled on optima determined by both fixed categorical predictors and an instantaneous scaling with a fixed covariate");
      if(is.null(intercept)) GS_head<-c("Ya", levels(as.factor(fixed.fact))) else GS_head<-levels(as.factor(fixed.fact));
      
    }
  
  
  else
    
    if(model.type=="mmANCOVA")
    {
      message("You have specified an OU model for a response variable modeled on optima determined by both fixed, categorical factors as well as covariates which themselves randomly evolve (modeled as Brownian-motions)");
      
      
      if(is.null(intercept)) GS_head<-c("Ya", levels(as.factor(fixed.fact))) else GS_head<-levels(as.factor(fixed.fact));
    }
  
  if(model.type=="mmfANCOVA")
  {
    message("You have specified an OU model for a response variable modeled on optima determined by both fixed, categorical factors as well as covariates which themselves randomly evolve (modeled as Brownian-motions)");
    
    
    if(is.null(intercept)) GS_head<-c("Ya", levels(as.factor(fixed.fact))) else GS_head<-levels(as.factor(fixed.fact));
  }
  else
    
    
    
    if(model.type=="rReg") message("You have specified an OU model for a response variable modeled on optima that are determined by randomly evolving covariates (modeled as Brownian-motions)")
  
  else
    if(model.type=="fReg") message("You have specified an OU model for a response variable modeled on optima that are determined by an instantaneous scaling with fixed covariates")
  
  else
    if(model.type=="mfReg") message("You have specified an OU model for a response variable modeled on optima that are determined by both an instantaneous scaling with fixed covariates and randomly evolving covariates (modeled as Brownian-motions)");
  message("")
  
  # Summarize dataset, response, predictors,  tree height and sample size and write to screen
  
  ms<-list(Dataset=search()[2], Response=deparse(substitute(response)), Fixed.factor=deparse(substitute(fixed.fact)),Fixed.covariates=deparse(substitute(fixed.cov)), Random.covariates=deparse(substitute(random.cov)), Sample.size=length(response[!is.na(response)]), Tree.height=max(times), Model.type=substitute(model.type))
  ms<-as.matrix(ms)
  colnames(ms)<-"Summary"
  print(ms)
  message("")
  message("GRID SEARCH PARAMETER SUPPORT")
  message("")
  
  # SPECIFY COMPONENTS THAT ARE COMMON TO ALL MODELS
  
  Y <- response[!is.na(response)]
  N <- length(Y)
  T <- times[terminal.twigs(topology)]
  T.term <- times[terminal.twigs(topology)]
  
  tia<-tsia(ancestor, time)
  tja<-tsja(ancestor, time)
  term<-terminal.twigs(topology)
  pt<-parse.tree(topology, times)
  ta<-pt$bt
  tij<-pt$dm
  
  num.prob<-matrix(data=0, nrow=N, ncol=N) #this matrix is included for cases where species split at the root;
  cm2<-matrix(data=0, nrow=N, ncol=N);
  gof<-matrix(data=0, nrow=length(half_life_values), ncol=length(vy_values), dimnames=list(half_life_values, vy_values));
  h.lives<-matrix(data=0, nrow=length(half_life_values), ncol=length(vy_values))
  ln2<-log(2)
  half_life_values<-rev(half_life_values)
  
  ## Cluster all parameters concerning phylogenetic tree
  treepar <- list(T = T,
                  T.term = T.term,
                  tia = tia,
                  tja = tja,
                  term = term,
                  pt = pt,
                  ta = ta,
                  tij = tij,
                  ultrametric = ultrametric,
                  topology = topology,
                  ancestor = ancestor,
                  times = times,
                  species = species)
  
  ## Cluster parameters concerning the type of model being run
  modelpar <- list(model.type = model.type,
                   response = response,
                   me.response = me.response,
                   fixed.fact = fixed.fact,
                   fixed.cov = fixed.cov,
                   me.fixed.cov = me.fixed.cov,
                   random.cov = random.cov,
                   me.random.cov = me.random.cov,
                   Y = Y,
                   N = N,
                   num.prob = num.prob,
                   cm2 = cm2,
                   gof = gof,
                   h.lives = h.lives,
                   half_life_values = half_life_values,
                   vy_values = vy_values,
                   support = support,
                   convergence = convergence,
                   intercept = intercept)
  
  
  # EVALUATE IF IT IS A FIXED FACTOR PREDICTOR OR INTERCEPT ONLY MODEL THEN SET UP APPROPRIATE DESIGN AND VARIANCE MATRICES AND ESTIMATE PARAMETERS WITHOUT ITERATED GLS
  
  if(model.type =="IntcptReg" || model.type == "ffANOVA")
  {
    if(model.type=="IntcptReg"){
      #regime.specs<-rep(1, times=length(topology)) Bjorn: Not used ? Prove me wrong.
    }
    else{
      regime.specs<-fixed.fact
      treepar$regime.specs <- regime.specs
    }
    
    cat(c("   ", "t1/2  ", "Vy    ", "Supp  ", GS_head), sep="   ");
    message(" ");
    
    ## "vectorgrid", expanded to include all combinations of HL + VY
    vector.grid <- make.vector.grid(modelpar)
    
    ## Apply regression function to all values of hl + vy in vectorgrid
    estimates <- apply(vector.grid, 1, IntcptReg, treepar, modelpar)
    sup2 <- sapply(estimates, function(e) e$support)
    
    ## Reshape vectorgrid as matrix
    gof <- matrix(sup2, ncol=length(vy_values), byrow=TRUE, dimnames = list(half_life_values, vy_values))
    
    # Search GOF matrix for best estimates of alpha and vy #
    ml<-max(gof)
    gof <- ifelse(gof <= ml-support, ml-support, gof) - ml
    gof=gof-ml
    
    ## Extract best estimates
    best.estimate <- estimates[sup2 == max(sup2)][[1]]
    alpha.est <- best.estimate$alpha.est
    vy.est <- best.estimate$vy.est
    beta.i <- best.estimate$beta0
    beta.i.var <- best.estimate$beta.i.var
    
    gls.beta0 <- beta.i
    X <- best.estimate$X
    V <- best.estimate$V
    
    ## Calculate model fit stats
    pred.mean <- X%*%gls.beta0
    g.mean <- (t(rep(1, times=N))%*%solve(V)%*%Y)/sum(solve(V));
    sst <- t(Y-g.mean)%*% solve(V)%*%(Y-g.mean)
    sse <-t (Y-pred.mean)%*%solve(V)%*%(Y-pred.mean)
    r.squared <- (sst-sse)/sst
    
  } # END OF FIXED PREDICTOR OR INTERCEPT ONLY PARAMETER ESTIMATION
  
  
  if(model.type =="ffANCOVA" || model.type == "fReg")
  {
    #n.pred<-length(pred[1,])
    fixed.pred<-data.frame(fixed.cov)
    n.fixed.pred<-length(fixed.pred[1,])
    fixed.pred<-matrix(data=fixed.pred[!is.na(fixed.pred)], ncol=n.fixed.pred)
    
    if(is.null(me.fixed.cov)) {
      me.fixed.pred<-matrix(data=0, nrow=N, ncol=n.fixed.pred)
    }else{
      me.fixed.pred<- matrix(data=me.fixed.cov[!is.na(me.fixed.cov)], ncol=n.fixed.pred)
    }
    if(is.null(mecov.fixed.cov)){
      me.cov<-matrix(data=0, nrow=N, ncol=n.fixed.pred)
    }else{
      me.cov<-matrix(data=me.cov.fixed.cov[!is.na(me.cov.fixed.cov)], ncol=n.fixed.pred)
    } 
    
    modelpar$me.cov <- me.cov
    modelpar$me.fixed.pred <- me.fixed.pred
    modelpar$fixed.pred <- fixed.pred
    modelpar$n.fixed.pred <- n.fixed.pred
    
    if(model.type=="fReg")
    {
      cat(c("   ", "t1/2  ", "Vy    ", "Supp  ", "Bo", if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov)), sep="   ");
      message("");
    }
    
    if(model.type=="ffANCOVA")
    {
      cat(c("   ", "t1/2  ", "Vy    ", "Supp  ", GS_head, if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov)), sep="   ");
      message("");
    }
    
    
    
    seed.fReg <- make.seed.fReg.ffANCOVA(treepar, modelpar)
    list2env(seed.fReg, envir = environment()) ## VERY BAD PRACTICE
    
    #print(names(seed.fReg))
    
    vector.grid <- make.vector.grid(modelpar)
    estimates <- apply(vector.grid, 1, fReg, treepar, modelpar, seed.fReg)
    sup2 <- sapply(estimates, function(e) e$support)
    gof <- matrix(sup2, ncol=length(vy_values), byrow=TRUE, dimnames = list(half_life_values, vy_values))
    
    # Search GOF matrix for best estimates of alpha and vy #
    
    ml<-max(gof)
    gof <- ifelse(gof <= ml-support, ml-support, gof) - ml
    gof=gof-ml
    
    best.estimate <- estimates[sup2 == max(sup2)][[1]]
    
    alpha.est <- best.estimate$alpha.est
    vy.est <- best.estimate$vy.est
    V <- V.est <- best.estimate$V
    gls.beta0 <- best.estimate$beta1
    X <- best.estimate$X
    beta.i.var <- best.estimate$beta.i.var
    
    V.inverse <- solve(V)
    
    # code for calculating SSE, SST and r squared
    
    pred.mean <- X%*%gls.beta0
    g.mean <- (t(rep(1, times=N))%*%solve(V)%*%Y)/sum(solve(V))
    sst <- t(Y-g.mean)%*% solve(V)%*%(Y-g.mean)
    sse <- t(Y-pred.mean)%*%solve(V)%*%(Y-pred.mean)
    r.squared <- (sst-sse)/sst
    
    
    adj <- matrix(data=0, ncol=ncol(X), nrow=N)  #PREDICTOR THETA
    for(i in 1:length(adj[1,]))
    {
      adj[,i] <- mean(X[,i]);
    }
    
    correction<-matrix(Vu%*%pseudoinverse(Vd+Vu)%*%(c(X)-c(adj)),  ncol=ncol(X), nrow=nrow(X), byrow=F)
    bias_corr<-pseudoinverse(t(X)%*%V.inverse%*%X)%*%t(X)%*%V.inverse%*%correction
    m<-length(gls.beta0);
    corrected_betas<-solve(diag(1,m,m)-bias_corr)%*%gls.beta0
    ###### End of Bias correction ######
    
    
  }  # END OF fReg AND ffANVOCA ESTIMATION ROUTINES must still add iterated GLS for me
  
  # EVALUATE IF IT IS A FIXED MODEL ANCOVA, MIXED MODEL ANCOVA OR RANDOM PREDICTOR REGRESSION, ESTIMATE PARAMETERS WITH ITERATED GLS TO A) TAKE MEASUREMENT VARIANCE INTO ACCOUNT OR B) RANDOM EFFECTS INTO ACCOUNT IN THE CASE OF THE MIXED MODEL AND REGRESSION
  
  if(model.type == "mmANCOVA" || model.type=="rReg")  ### more models here
  {
    # SET UP INITIAL MATRICES FOR MULTIPLE REGRESSION AND CALCULATE THETA AND SIGMA FOR RANDOM PREDICTOR / S
    
    pred<-data.frame(random.cov)
    n.pred<-length(pred[1,])
    pred<-matrix(data=pred[!is.na(pred)], ncol=n.pred)
    modelpar$pred <- pred
    
    if(is.null(me.random.cov)){
      me.pred<-matrix(data=0, nrow=N, ncol=n.pred)
    }  else{
      me.pred<-matrix(data=me.random.cov[!is.na(me.random.cov)], ncol=n.pred)
    } 
    if(is.null(mecov.random.cov)) {
      me.cov<-matrix(data=0, nrow=N, ncol=n.pred)
    }else{
      me.cov<-matrix(data=mecov.random.cov[!is.na(mecov.random.cov)], ncol=n.pred)
    }
    
    s.X<-matrix(data=0, ncol=n.pred)  # PREDICTOR SIGMA
    for(i in 1:n.pred)
    {
      s.X[,i] <- as.numeric(sigma.X.estimate(pred[,i], me.pred[,i], topology, times)[2]);
    }
    
    
    
    theta.X<-matrix(data=0, ncol=n.pred)  #PREDICTOR THETA
    for(i in 1:n.pred)
    {
      theta.X[,i] <- as.numeric(sigma.X.estimate(pred[,i],me.pred[,i], topology, times)[1]);
    }
    
    modelpar$me.pred <- me.pred
    modelpar$s.X <- s.X
    modelpar$theta.X <- theta.X
    modelpar$me.cov <- me.cov
    modelpar$n.pred <- n.pred
    
    
    # END OF RANDOM PREDICTOR THETA AND SIGMA ESTIMATES
    ## INITIAL OLS ESTIMATES TO SEED ITERATED GLS
    
    if(model.type=="rReg")
    {
      seed <- seed.rReg(treepar, modelpar)
      list2env(seed, envir = environment()) ## Quick, dirty bugfix: NOT A GOOD ONE. VERY BAD. Check for Vu, Vd throughout next 200 lines
    }
    
    
    if(model.type=="mmANCOVA")
    {
      
      
      regime.specs<-fixed.fact;
      n.fixed<-length(levels(as.factor(regime.specs)))
      regime.specs<-as.factor(regime.specs)
      
      ## Precompute "regimes" for the weight.matrix() in the regression
      weight.m.regimes <- regimes(topology, times, regime.specs, term)
      
      x.ols<-cbind(weight.matrix(1000000000000000000000, topology, times, N, regime.specs, fixed.cov=NULL, intercept), pred);
      
      for (i in length(x.ols[1,]):1){
        if(sum(x.ols[,i]) == 0) {x.ols<-x.ols[,-i]; n.fixed<-n.fixed-i}  #removes internal regimes that have only zero entries
      }
      beta1<-solve(t(x.ols)%*%x.ols)%*%(t(x.ols)%*%Y)
      
      ## Setting up the Vu and Vd matrices ##
      Vd<-matrix(0,ncol=(N*length(beta1[,1])), nrow=(N*length(beta1[,1])))
      xx<-seq(from=1, to	=length(Vd[,1]), by=N)
      xx<-xx[-(1: n.fixed)]
      yy<-seq(from=N, to	=length(Vd[,1]), by=N)
      yy<-yy[-(1: n.fixed)]
      
      for (i in seq(from=1, to=nrow(s.X), by=1)){
        Vd[xx[i]:yy[i],xx[i]:yy[i]]<-pt$bt*s.X[,i]
      }
      
      Vu<-diag(c(rep(0,N* n.fixed), c(as.numeric(na.exclude(me.pred)))))
      
      tmp2 <- Vu + Vd
      
      error_condition<-Vu-(Vu%*%pseudoinverse(tmp2)%*%Vu)
      
      xx<-seq(from=1, to=length(Vu[,1]), by=N)
    }
    
    
    # GRID ESTIMATION ROUTINE AND ITERATED GLS FOR MODELS THAT INCLUDE RANDOM EFFECTS
    
    if(model.type=="mmANCOVA")
    {
      cat(c("   ", "t1/2  ", "Vy    ", "Supp  ", GS_head, if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), sep="   ");
      message(" ");
      
      vector.grid <- cbind(sort(rep(half_life_values, length(vy_values)), decreasing = TRUE), rep(vy_values, length(half_life_values)))
      estimates <- apply(vector.grid, 1,sup.mmANCOVA, N=N, me.response = me.response, ta = ta, tia = tia, tja = tja, tij = tij, T = T, topology = topology, times = times, model.type = model.type, ultrametric = ultrametric, Y = Y,  pred = pred, xx = xx, beta1 = beta1, error_condition = error_condition, s.X = s.X, n.pred = n.pred, num.prob = num.prob, cm2 = cm2, me.pred = me.pred, me.cov = me.cov, convergence = convergence, n.fixed = n.fixed, x.ols = x.ols, regime.specs = regime.specs, intercept = intercept, term = term, weight.m.regimes = weight.m.regimes)
      sup2 <- sapply(estimates, function(e) e$support)
      gof <- matrix(sup2, ncol=length(vy_values), byrow=TRUE, dimnames = list(half_life_values, vy_values))
      
      ml<-max(gof)
      gof <- ifelse(gof <= ml-support, ml-support, gof) - ml
      
      
      #best.estimate <- estimates[sup2 == max(na.exclude(sup2))][[1]]
      best.estimate <- estimates[which(sup2 == max(na.exclude(sup2)))][[1]]
      
      V <- V.est <- best.estimate$V
      gls.beta1 <- beta.est <- best.estimate$beta1
      X <- best.estimate$X
      beta.i.var <- beta.var.est <- best.estimate$beta1.var
      alpha.est <- best.estimate$alpha.est
      vy.est <- best.estimate$vy.est
      
      print(best.estimate)
      
      
      # END OF GRID SETUP,START OF GRID SEARCH FOR BEST ALPHA AND VY ESTIMATES #



      
      
      n.fixed<-length(levels(as.factor(regime.specs)))   ### reset before final regression
      
      pred.mean<-X%*%gls.beta1
      g.mean<-(t(rep(1, times=N))%*%solve(V)%*%Y)/sum(solve(V));
      sst<-t(Y-g.mean)%*% solve(V)%*%(Y-g.mean)
      sse<-t(Y-pred.mean)%*%solve(V)%*%(Y-pred.mean)
      r.squared<-(sst-sse)/sst
      
      ###### Start of Bias correction ######
      adj<-matrix(data=0, ncol= ncol(X), nrow=N)
      for(i in 1:n.pred)
      {
        adj[,(n.fixed+i)] <- as.numeric(sigma.X.estimate(pred[,i], me.pred[,i], topology, times)[1]);
      }
      V.inverse<-solve(V)
      
      ## TEMP bugfix bjorn
      if (model.type == "rReg") Vu <- seed$Vu
      ##
      
      correction<-matrix(Vu%*%pseudoinverse(Vd+Vu)%*%(c(X)-c(adj)),  ncol=ncol(X), nrow=nrow(X), byrow=F)
      bias_corr<-pseudoinverse(t(X)%*%V.inverse%*%X)%*%t(X)%*%V.inverse%*%correction
      m<-length(gls.beta1);
      K<-solve(diag(1,m,m)-bias_corr)
      corrected_betas<-solve(diag(1,m,m)-bias_corr)%*% gls.beta1
      ###### End of Bias correction ######
      
    } # END OF ESTIMATION MIXED MODEL ANCOVA
    
    
    if(model.type=="rReg")
    {
      if(ultrametric==TRUE)
      {
        cat(c("   ", "t1/2  ", "Vy    ", "Supp  ", "K     ", if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), sep="   ");
      }
      else
        cat(c("   ", "t1/2  ", "Vy    ", "Supp  ", "Ya    ", "Xa    " ,"Bo    ",  if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), sep="   ");
      
      message(" ");
      
      grid_hl_vy <- cbind(sort(rep(half_life_values, length(vy_values)), decreasing = TRUE), rep(vy_values, length(half_life_values)))
      
      ## Old reg func
      #estimates <- apply(grid_hl_vy, 1,sup.rReg, modelpar, treepar, seed)
      
      ## Try the closure instead
      sup.rReg <- make.sup.rReg(modelpar, treepar, seed)
      
      ## Print the closure for given treepar, modelpar, seed to file. Requires library(pryr)
      #dput(unenclose(sup.rReg), "~/slouch/files/sup.rReg.unenclosed.txt")
      
      ## Apply the regression function to all values of hl & vy in grid_hl_vy
      estimates <- apply(grid_hl_vy, 1, sup.rReg)
      
      
      sup2 <- sapply(estimates, function(e) e$support)
      gof <- matrix(sup2, ncol=length(vy_values), byrow=TRUE, dimnames = list(half_life_values, vy_values))
      ml<-max(na.exclude(gof))
      gof <- ifelse(gof <= ml-support, ml-support, gof) - ml
      gof <- ifelse(is.na(gof), 0, gof)
      
      
      which2 <- which(sup2 == max(na.exclude(sup2)))
      
      ## Find the regression for which the support value is maximized
      best.estimate <- estimates[[which.max(sup2)]]
      V.est <- best.estimate$V
      beta.est <- best.estimate$beta1
      X <- best.estimate$X
      beta.var.est <- best.estimate$beta1.var
      alpha.est <- best.estimate$alpha.est
      vy.est <- best.estimate$vy.est
      
      #return(estimates)
      #return(sup2)
      
      beta.i.var <- beta.var.est
      beta.i <- gls.beta1 <- beta.est
      V <- V.est
      
      V.inverse<-solve(V)
      
      X1<-cbind(1, pred)
      ev.beta.i.var<-pseudoinverse(t(X1)%*%V.inverse%*%X1)
      ev.beta.i<-ev.beta.i.var%*%(t(X1)%*%V.inverse%*%Y)
      
      
      if(alpha.est==Inf)
      {
        glsyx.beta1<- gls.beta1
        glsyx.beta1.var <- beta.var.est
      }
      else
      {
        if(ultrametric==FALSE)
        {
          ind.par<-matrix(data=0, nrow=N, ncol=4, dimnames=list(NULL, c("Bo", "Bi.Xia", "Yo", "Sum")))
          ind.par[,1]<-beta.i[1]*X[,1]
          ind.par[,2]<-beta.i[2]*X[,2]
          ind.par[,3]<-beta.i[3]*X[,3]
          ind.par[,4]<-ind.par[,1]+ind.par[,2]+ind.par[,3]
          mean.Bo=mean(ind.par[,4])
        }
        glsyx.beta1 <- ev.beta.i
        glsyx.beta1.var <- ev.beta.i.var
      }
      # END OF HALFLIFE 0 CONDITION #
      
      pred.mean<-X%*%gls.beta1
      g.mean<-(t(rep(1, times=N))%*%solve(V)%*%Y)/sum(solve(V))
      sst<-t(Y-g.mean)%*% solve(V)%*%(Y-g.mean)
      sse<-t(Y-pred.mean)%*%solve(V)%*%(Y-pred.mean)
      r.squared<-(sst-sse)/sst
      
      ###### Start of Bias correction ######
      adj<-matrix(data=0, ncol= 1+ n.pred, nrow=N)
      for(i in 1:n.pred)
      {
        adj[,(1+i)] <- as.numeric(sigma.X.estimate(pred[,i], me.pred[,i], topology, times)[1])
      }
      
      if(ultrametric==FALSE) {
        Vd<-Vd[(length(Vd[1,])-(N*2)+1):length(Vd[1,]),(length(Vd[1,])-(N*2)+1):length(Vd[1,])]
        Vu<-Vu[(length(Vu[1,])-(N*2)+1):length(Vu[1,]),(length(Vu[1,])-(N*2)+1):length(Vu[1,])]
      }
      
      correction<-matrix(Vu%*%pseudoinverse(Vd+Vu)%*%(c(X1)-c(adj)),  ncol=ncol(X1), nrow=nrow(X1), byrow=F)
      bias_corr<-pseudoinverse(t(X1)%*%V.inverse%*%X1)%*%t(X1)%*%V.inverse%*%correction
      m<-length(glsyx.beta1)
      corrected_betas<-solve(diag(1,m,m)-bias_corr)%*% glsyx.beta1
      
    } # END OF RANDOM COVARIATE REGRESSION ESTIMATION
  }# END OF FIXED COVARIATE, MIXED OR RANDOM MODELS PARAMETER ESTIMATION
  
  
  
  
  
  
  
  
  
  
  # EVALUATE IF IT IS A FIXED AND RANDOM COVARIATE ANCOVA OR REGRESSION MODEL ESTIMATE PARAMETERS WITH ITERATED GLS TO A) TAKE MEASUREMENT VARIANCE INTO ACCOUNT OR B) RANDOM EFFECTS INTO ACCOUNT IN THE CASE OF THE MIXED MODEL AND REGRESSION
  
  if(model.type == "mmfANCOVA" || model.type=="mfReg")
  {
    # SET UP INITIAL MATRICES FOR MULTIPLE REGRESSION AND CALCULATE THETA AND SIGMA FOR RANDOM PREDICTOR / S
    
    pred<-data.frame(random.cov)
    n.pred<-length(pred[1,])
    pred<-matrix(data=pred[!is.na(pred)], ncol=n.pred);
    if(is.null(me.random.cov)) me.pred<-matrix(data=0, nrow=N, ncol=n.pred) else me.pred<-matrix(data=me.random.cov[!is.na(me.random.cov)], ncol=n.pred);
    if(is.null(mecov.random.cov)) me.cov<-matrix(data=0, nrow=N, ncol=n.pred) else me.cov<-matrix(data=mecov.random.cov[!is.na(mecov.random.cov)], ncol=n.pred);
    
    s.X<-matrix(data=0, ncol=n.pred)  # PREDICTOR SIGMA
    for(i in 1:n.pred)
    {
      s.X[,i] <- as.numeric(sigma.X.estimate(pred[,i],me.pred[,i], topology, times)[2]);
    }
    
    theta.X<-matrix(data=0, ncol=n.pred)  #PREDICTOR THETA
    for(i in 1:n.pred)
    {
      theta.X[,i] <- as.numeric(sigma.X.estimate(pred[,i],me.pred[,i], topology, times)[1]);
    }
    
    
    # END OF RANDOM PREDICTOR THETA AND SIGMA ESTIMATES
    
    # FIXED COVARIATES
    
    fixed.pred<-data.frame(fixed.cov);
    n.fixed.pred<-length(fixed.pred[1,]);
    fixed.pred<-matrix(data=fixed.pred[!is.na(fixed.pred)], ncol=n.fixed.pred);
    if(is.null(me.fixed.cov)) me.fixed.pred<-matrix(data=0, nrow=N, ncol=n.fixed.pred) else me.fixed.pred<- matrix(data=me.fixed.cov[!is.na(me.fixed.cov)], ncol=n.fixed.pred);
    if(is.null(mecov.fixed.cov)) me.fixed.cov<-matrix(data=0, nrow=N, ncol=n.fixed.pred) else me.fixed.cov<-matrix(data=me.cov.fixed.cov[!is.na(me.cov.fixed.cov)], ncol=n.fixed.pred);
    
    ## INITIAL OLS ESTIMATES TO SEED ITERATED GLS
    if(model.type=="mfReg")
    {
      x.ols<-cbind(1, fixed.pred, pred);
      beta1<-solve(t(x.ols)%*%x.ols)%*%(t(x.ols)%*%Y)
      if(ultrametric == FALSE) beta1<-rbind(0, 0, beta1); # 2 additional parameter seeds for Ya and Xa
      
      
      #Defining the dimensionality of Vd
      Vd<-matrix(0,ncol=(N*length(beta1[,1])), nrow=(N*length(beta1[,1])))
      
      
      #Putting in elements in VD for fixed covariates
      true_var<-matrix(data=0, ncol=n.fixed.pred, nrow=N);
      for (i in 1:n.fixed.pred)
      {
        true_var[,i]<-var(na.exclude(fixed.pred[,i]))-as.numeric(na.exclude(me.fixed.pred[,i]))
      }
      
      true_var<-c(true_var)
      if(ultrametric == TRUE) Vd[1:((N*n.fixed.pred)+N),1:((N*n.fixed.pred)+N)]<-diag(c(rep(0,N),true_var)) else Vd[((3*N+1):((3*N+(n.fixed.pred*N)))),((3*N+1):((3*N+(n.fixed.pred*N))))]<-diag(c(true_var))
      
      
      #Putting in elements in VD for random covariates
      
      xx<-seq(from=1, to	=length(Vd[,1]), by=N)
      
      if(ultrametric == TRUE) xx<-xx[-(1:(1+ n.fixed.pred))] else xx<-xx[-(1:(3+ n.fixed.pred))]
      
      yy<-seq(from=N, to	=length(Vd[,1]), by=N)
      
      if(ultrametric == TRUE) yy<-yy[-(1:(1+ n.fixed.pred))] else yy<-yy[-(1:(3+ n.fixed.pred))]
      
      
      for (i in seq(from=1, to=nrow(s.X), by=1)){
        Vd[xx[i]:yy[i],xx[i]:yy[i]]<-pt$bt*s.X[,i]
        
      }
      
      
      # Defining Vu
      if(ultrametric == TRUE) Vu<-diag(c(rep(0,N), c(as.numeric(na.exclude(me.fixed.pred))),c(as.numeric(na.exclude(me.pred))))) else Vu<-diag(c(rep(0,N*3), c(as.numeric(na.exclude(me.pred))), c(as.numeric(na.exclude(me.fixed.pred)))))
      
      error_condition<-Vu-(Vu%*%pseudoinverse(Vu+Vd)%*%Vu)
      
      mybiglist <- list()
      
      xx<-seq(from=1, to=length(Vu[,1]), by=N)
      mybiglist <- list()
      
      
      for (i in seq(from=1, to=nrow(beta1), by=1)){
        for (j in seq(from=1, to=nrow(beta1), by=1)) {
          tmp <- list(error_condition[xx[i]:(i*N),xx[j]:(j*N)]*beta1[i]*beta1[j])
          mybiglist[xx[i]+j] <- tmp
        }
        
      }
      
      
      mybiglist <-rmNullObs(mybiglist)
      obs_var_con<-Reduce('+', mybiglist)
      
      
    }
    
    if(model.type=="mmfANCOVA")
    {
      regime.specs<-fixed.fact
      n.fixed<-length(levels(as.factor(regime.specs)))
      regime.specs<-as.factor(regime.specs)
      x.ols<-cbind(weight.matrix(10000000000, topology, times, N, regime.specs, fixed.pred, intercept), pred)
      beta1<-solve(t(x.ols)%*%x.ols)%*%(t(x.ols)%*%Y)
      
      
      #Defining the dimensionality of Vd ## Might need to change the dimensionality of this matrix for different versions of the model and how that impacts the number of columns in x.ols
      Vd<-matrix(0,ncol=(N*length(beta1[,1])), nrow=(N*length(beta1[,1])))
      
      
      #Putting in elements in VD for fixed covariates
      true_var<-matrix(data=0, ncol=n.fixed.pred, nrow=N);
      for (i in 1:n.fixed.pred)
      {
        true_var[,i]<-var(na.exclude(fixed.pred[,i]))-as.numeric(na.exclude(me.fixed.pred[,i]))
      }
      
      true_var<-c(true_var)
      Vd[(((N* n.fixed)+(1)):(((N* n.fixed)+(1))+((N*n.fixed.pred)-1))),(((N* n.fixed)+(1)):(((N* n.fixed)+(1))+((N*n.fixed.pred)-1)))]<-diag(c(true_var))
      
      
      #Putting in elements in VD for random covariates
      
      xx<-seq(from=1, to	=length(Vd[,1]), by=N)
      
      if(ultrametric == TRUE) xx<-xx[-(1:(n.fixed+n.fixed.pred))] else xx<-xx[-(1:(n.fixed+ n.fixed.pred))]
      
      yy<-seq(from=N, to	=length(Vd[,1]), by=N)
      
      if(ultrametric == TRUE) yy<-yy[-(1:(n.fixed+n.fixed.pred))] else yy<-yy[-(1:(n.fixed+n.fixed.pred))]
      
      
      for (i in seq(from=1, to=nrow(s.X), by=1)){
        Vd[xx[i]:yy[i],xx[i]:yy[i]]<-pt$bt*s.X[,i]
        
      }
      
      # Defining Vu
      if(ultrametric == TRUE) Vu<-diag(c(rep(0,(N*(n.fixed))), c(as.numeric(na.exclude(me.fixed.pred))),c(as.numeric(na.exclude(me.pred))))) else Vu<-diag(c(rep(0,N*(2+ n.fixed))), c(as.numeric(na.exclude(me.fixed.pred))), c(as.numeric(na.exclude(me.pred))))
      
      error_condition<-Vu-(Vu%*%pseudoinverse(Vu+Vd)%*%Vu)
      
      mybiglist <- list()
      
      xx<-seq(from=1, to=length(Vu[,1]), by=N)
      mybiglist <- list()
      
      
      for (i in seq(from=1, to=nrow(beta1), by=1)){
        for (j in seq(from=1, to=nrow(beta1), by=1)) {
          tmp <- list(error_condition[xx[i]:(i*N),xx[j]:(j*N)]*beta1[i]*beta1[j])
          mybiglist[xx[i]+j] <- tmp
        }
      }
      mybiglist <-rmNullObs(mybiglist)
      obs_var_con<-Reduce('+', mybiglist)
    }
    
    
    
    # GRID ESTIMATION ROUTINE AND ITERATED GLS FOR MODELS THAT INCLUDE RANDOM EFFECTS
    
    if(model.type=="mmfANCOVA")
    {
      cat(c("   ", "t1/2  ", "Vy    ", "Supp  ", GS_head, if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov), if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), sep="   ");
      
      
      message(" ");
      
      for(i in 1:length(half_life_values))
      {
        for(k in 1:length(vy_values))
        {
          if(half_life_values[i]==0) a<-1000000000000000000000 else a <- ln2/half_life_values[i];
          vy <- vy_values[k];
          X<-cbind(weight.matrix(a, topology, times, N, regime.specs, fixed.pred, intercept), (1-(1-exp(-a*T))/(a*T))*pred);
          if(length(X[1,]) > length(beta1)) {beta1<-as.matrix(c(0, beta1)); n.fixed<-n.fixed+1}
          if(length(X[1,])< length(beta1)) {beta1<-solve(t(x.ols)%*%x.ols)%*%(t(x.ols)%*%Y);n.fixed<-length(levels(as.factor(regime.specs))); print("The Ya parameter is dropped as its coefficient is too small");}
          
          # CODE FOR ESTIMATING BETA USING ITERATED GLS
          
          con.count<-0;  # Counter for loop break if Beta's dont converge #
          repeat
          {
            if(half_life_values[i]==0)
            {
              X<-cbind(weight.matrix(1000000000000000000000, topology, times, N, regime.specs, fixed.pred, intercept), pred);
              #V<-diag(rep(vy, times=N))+me.response+diag(as.numeric(me.pred%*%(beta1[(n.fixed+1+n.fixed.pred):length(beta1),]*beta1[(n.fixed+1+n.fixed.pred):length(beta1),])))-diag(as.numeric(me.cov%*%(2*beta1[(n.fixed+1+n.fixed.pred):length(beta1),]))) + diag(as.numeric(me.fixed.pred%*%(beta1[(n.fixed+1):(length(beta1)-n.pred),]*beta1[(n.fixed+1):(length(beta1)-n.pred),])))-diag(as.numeric(me.fixed.cov%*%(2*beta1[(n.fixed+1):(length(beta1)-n.pred),])));
              
              V<-diag(rep(vy, times=N))+na.exclude(me.response)+ obs_var_con-diag(as.numeric(me.cov%*%(2*beta1[(n.fixed+1+n.fixed.pred):length(beta1),])))-diag(as.numeric(me.fixed.cov%*%(2*beta1[(n.fixed+1):(length(beta1)-n.pred),])));
              
            }
            else
            {
              
              X<-cbind(weight.matrix(a, topology, times, N, regime.specs, fixed.pred, intercept), (1-(1-exp(-a*T))/(a*T))*pred);
              
              
              s1<-as.numeric(s.X%*%(beta1[(n.fixed+1+n.fixed.pred):length(beta1),]*beta1[(n.fixed+1+n.fixed.pred):length(beta1),]));
              
              
              for(p in 1:N)
              {
                for(q in 1:N)
                {
                  if(ta[q,p]==0)num.prob[q,p]=1 else num.prob[q,p]=(1-exp(-a*ta[q,p]))/(a*ta[q,p]);
                }
              }
              cm1<-(s1/(2*a)+vy)*(1-exp(-2*a*ta))*exp(-a*tij);
              for(p in 1:N)
              {
                for(q in 1:N)
                {
                  cm2[p,q]<-(((1-exp(-a*T[p]))/(a*T[p]))*((1-exp(-a*T[q]))/(a*T[q]))-(exp(-a*tia[p, q])*(1-exp(-a*T[p]))/ (a*T[q])+ exp(-a*tja[p, q])*(1-exp(-a*T[p]))/(a*T[p]))*(num.prob[p,q]));
                }
              }
              
              mv<-diag(rowSums(matrix(data=as.numeric(me.pred)*t(kronecker(beta1[(n.fixed+1+n.fixed.pred):length(beta1), ], (1-(1-exp(-a*T))/(a*T)))^2), ncol=n.pred)));
              mcov<-diag(rowSums(matrix(data=as.numeric(me.cov)*t(kronecker(2*beta1[(n.fixed+1+n.fixed.pred):length(beta1),], (1-(1-exp(-a*T))/(a*T)))), ncol=n.pred)));
              mv.fixed<-diag(rowSums(matrix(data=as.numeric(me.fixed.pred)*t(kronecker(beta1[(n.fixed+1):(length(beta1)-n.pred), ], rep(1, times=N))), ncol=n.fixed.pred)));
              mcov.fixed<-diag(rowSums(matrix(data=as.numeric(me.fixed.cov)*t(kronecker(2*beta1[(n.fixed+1):(length(beta1)-n.pred),], rep(1, times=N))), ncol=n.fixed.pred)));
              
              
              
              #V<-cm1+(s1*ta*cm2)+me.response+mv+ mv.fixed-mcov-mcov.fixed;
              
              V<-cm1+(s1*ta*cm2)+na.exclude(me.response)+obs_var_con-mcov-mcov.fixed;
              
              
              obs_var_con
            } # END OF If ELSE CONDITION FOR HALF-LIFE 0 OR NOT
            
            # INTERMEDIATE ESTIMATION OF OPTIMAL REGRESSION #
            
            V.inverse<-solve(V)
            if(half_life_values[i]==0)
            {
              beta.i<-pseudoinverse(t(X)%*%V.inverse%*%X)%*%(t(X)%*%V.inverse%*%Y)
              test<-matrix(nrow=(length(beta.i)))
              for(f in 1:(length(beta.i)))
              {
                if(abs(as.numeric(beta.i[f]-beta1[f]))<=convergence) test[f]=0 else test[f]=1
              }
              if(sum(test)==0) break
              con.count=con.count+1
              if(con.count >= 50)
              {
                message("Warning, estimates did not converge after 50 iterations, last estimates printed out")
                break
              }
              
              beta1<-beta.i
            }
            else
            {
              
              beta.i<-pseudoinverse(t(X)%*%V.inverse%*%X)%*%(t(X)%*%V.inverse%*%Y)
              test<-matrix(nrow=(length(beta.i)))
              for(f in 1:(length(beta.i)))
              {
                if(abs(as.numeric(beta.i[f]-beta1[f]))<=convergence) test[f]=0 else test[f]=1
              }
              if(sum(test)==0) break
              con.count=con.count+1
              if(con.count >= 50)
              {
                message("Warning, estimates did not converge after 50 iterations, last estimates printed out")
                break
              }
              
              beta1<-beta.i
            }
          }
          
          
          ### END OF ITERATED GLS ESTIMATION FOR BETA #
          
          if(half_life_values[i]==0)
          {
            X<-cbind(weight.matrix(1000000000000000000000, topology, times, N, regime.specs, fixed.pred, intercept), pred)
            #V<-diag(rep(vy, times=N))+me.response+diag(as.numeric(me.pred%*%(beta1[(n.fixed+1+n.fixed.pred):length(beta1),]*beta1[(n.fixed+1+n.fixed.pred):length(beta1),])))-diag(as.numeric(me.cov%*%(2*beta1[(n.fixed+1+n.fixed.pred):length(beta1),]))) + diag(as.numeric(me.fixed.pred%*%(beta1[(n.fixed+1):(length(beta1)-n.pred),]*beta1[(n.fixed+1):(length(beta1)-n.pred),])))-diag(as.numeric(me.fixed.cov%*%(2*beta1[(n.fixed+1):(length(beta1)-n.pred),])));
            
            V<-diag(rep(vy, times=N))+na.exclude(me.response)+ obs_var_con-diag(as.numeric(me.cov%*%(2*beta1[(n.fixed+1+n.fixed.pred):length(beta1),])))-diag(as.numeric(me.fixed.cov%*%(2*beta1[(n.fixed+1):(length(beta1)-n.pred),])));
            
            
            V.inverse<-solve(V)
            eY<-X%*%beta1
            resid<-Y-eY;
            gof[i, k] <- -N/2*log(2*pi)-0.5*log(det(V))-0.5*(t(resid) %*% V.inverse%*%resid);
          }
          else
          {
            s1<-as.numeric(s.X%*%(beta1[(n.fixed+1+n.fixed.pred):length(beta1),]*beta1[(n.fixed+1+n.fixed.pred):length(beta1),]));
            for(p in 1:N)
            {
              for(q in 1:N)
              {
                if(ta[q,p]==0)num.prob[q,p]=1 else num.prob[q,p]=(1-exp(-a*ta[q,p]))/(a*ta[q,p]);
              }
            }
            cm1<-(s1/(2*a)+vy)*(1-exp(-2*a*ta))*exp(-a*tij);
            for(p in 1:N)
            {
              for(q in 1:N)
              {
                cm2[p,q]<-(((1-exp(-a*T[p]))/(a*T[p]))*((1-exp(-a*T[q]))/(a*T[q]))-(exp(-a*tia[p, q])*(1-exp(-a*T[p]))/(a*T[q])+ exp(-a*tja[p, q])*(1-exp(-a*T[p]))/(a*T[p]))*(num.prob[p,q]));
              }
            }
            X<-cbind(weight.matrix(a, topology, times, N, regime.specs, fixed.pred, intercept), (1-(1-exp(-a*T))/(a*T))*pred);
            mv<-diag(rowSums(matrix(data=as.numeric(me.pred)*t(kronecker(beta1[(n.fixed+1+n.fixed.pred):length(beta1), ], (1-(1-exp(-a*T))/(a*T)))^2), ncol=n.pred)));
            mcov<-diag(rowSums(matrix(data=as.numeric(me.cov)*t(kronecker(2*beta1[(n.fixed+1+n.fixed.pred):length(beta1),], (1-(1-exp(-a*T))/(a*T)))), ncol=n.pred)));
            mv.fixed<-diag(rowSums(matrix(data=as.numeric(me.fixed.pred)*t(kronecker(beta1[(n.fixed+1):(length(beta1)-n.pred), ], rep(1, times=N))), ncol=n.fixed.pred)));
            mcov.fixed<-diag(rowSums(matrix(data=as.numeric(me.fixed.cov)*t(kronecker(2*beta1[(n.fixed+1):(length(beta1)-n.pred),], rep(1, times=N))), ncol=n.fixed.pred)));
            
            V<-cm1+(s1*ta*cm2)+na.exclude(me.response)+ obs_var_con -mcov-mcov.fixed;
            V.inverse<-solve(V)
            
            eY<-X%*%beta1
            
            resid<-Y-eY;
            gof[i, k] <- -N/2*log(2*pi)-0.5*log(det(V))-0.5*(t(resid) %*% V.inverse%*%resid);
          }  # END OF CONDITION FOR HALF-LIFE = 0 #
          print(as.numeric(round(cbind(if(a!=0)log(2)/a else 0.00, vy, gof[i,k], t(beta1)), 4)))
        }
      }
      
      
      
      # END OF GRID SETUP,START OF GRID SEARCH FOR BEST ALPHA AND VY ESTIMATES #
      
      x<-rev(half_life_values)
      y<-vy_values
      z<-gof;
      ml<-max(z);
      for(i in 1:length(half_life_values))
      {
        for(j in 1:length(vy_values))
        {
          if(gof[i,j]==ml){alpha.est=log(2)/half_life_values[i]; vy.est=vy_values[j]}
        }
      }
      for(i in 1:length(half_life_values))
      {
        for(j in 1:length(vy_values))
        {
          if(gof[i,j]<=ml-support)gof[i, j]=ml-support;
        }
      }
      gof=gof-ml
      
      
      n.fixed<-length(levels(as.factor(regime.specs)))   ### reset before final regression
      
      
      # FINAL OPTIMAL REGRESSION USING BEST ALPHA AND VY ESTIMATES #
      
      if(alpha.est==Inf || alpha.est >=1000000000000000000000)
      {
        x.ols<-cbind(weight.matrix(1000000000000000000000, topology, times, N, regime.specs, fixed.pred, intercept), pred)
        gls.beta1<-solve(t(x.ols)%*%x.ols)%*%(t(x.ols)%*%Y)
        con.count<-0;
        repeat
        {
          
          s1<-as.numeric(s.X%*%(gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]));
          X<-cbind(weight.matrix(1000000000000000000000, topology, times, N, regime.specs, fixed.cov, intercept), pred)
          #V<-diag(rep(vy, times=N))+me.response+diag(as.numeric(me.pred%*%(gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),])))-diag(as.numeric(me.cov%*%(2*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]))) + diag(as.numeric(me.fixed.pred%*%(gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),]*gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),])))-diag(as.numeric(me.fixed.cov%*%(2*gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),])));
          
          V<-diag(rep(vy, times=N))+na.exclude(me.response)+ obs_var_con -diag(as.numeric(me.cov%*%(2*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]))) -diag(as.numeric(me.fixed.cov%*%(2*gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),])));
          
          V.inverse<-solve(V)
          beta.i.var<-ev.beta.i.var<-pseudoinverse(t(X)%*%V.inverse%*%X)
          beta.i<-beta.i.var%*%(t(X)%*%V.inverse%*%Y)
          test<-matrix(nrow=(length(beta.i)))
          for(f in 1:(length(beta.i)))
          {
            if(abs(as.numeric(beta.i[f]-gls.beta1[f]))<=convergence) test[f]=0 else test[f]=1
          }
          if(sum(test)==0) break
          con.count=con.count+1
          if(con.count >= 50)
          {
            message("Warning, estimates did not converge after 50 iterations, last estimates printed out")
            break
          }
          gls.beta1<-beta.i
        }
        gls.beta1<-beta.i
        X<-cbind(weight.matrix(1000000000000000000000, topology, times, N, regime.specs, fixed.pred, intercept), pred)
        #V<-diag(rep(vy, times=N))+me.response+diag(as.numeric(me.pred%*%(gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),])))-diag(as.numeric(me.cov%*%(2*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]))) + diag(as.numeric(me.fixed.pred%*%(gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),]*gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),])))-diag(as.numeric(me.fixed.cov%*%(2*gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),])));
        
        V<-diag(rep(vy, times=N))+na.exclude(me.response)+  obs_var_con -diag(as.numeric(me.cov%*%(2*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]))) -diag(as.numeric(me.fixed.cov%*%(2*gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),])));
        
        pred.mean<-X%*%gls.beta1
        g.mean<-(t(rep(1, times=N))%*%solve(V)%*%Y)/sum(solve(V));
        sst<-t(Y-g.mean)%*% solve(V)%*%(Y-g.mean)
        
        sse<-t(Y-pred.mean)%*%solve(V)%*%(Y-pred.mean)
        
        r.squared<-(sst-sse)/sst
        
        
      }
      else
      {
        x.ols<-cbind(weight.matrix(1000000000000000000000, topology, times, N, regime.specs, fixed.pred, intercept), pred)
        gls.beta1<-solve(t(x.ols)%*%x.ols)%*%(t(x.ols)%*%Y)
        con.count<-0;
        
        X<-cbind(weight.matrix(alpha.est, topology, times, N, regime.specs, fixed.pred, intercept), (1-(1-exp(-alpha.est*T))/(alpha.est*T))*pred);
        if(length(X[1,]) > length(gls.beta1)) {gls.beta1<-as.matrix(c(0, gls.beta1)); n.fixed<-n.fixed+1}
        if(length(X[1,])< length(gls.beta1)) {gls.beta1<-solve(t(x.ols)%*%x.ols)%*%(t(x.ols)%*%Y);n.fixed<-length(levels(as.factor(regime.specs)))}
        repeat
        {
          
          X<-cbind(weight.matrix(alpha.est, topology, times, N, regime.specs, fixed.pred, intercept), (1-(1-exp(-alpha.est*T))/(alpha.est*T))*pred);
          s1<-as.numeric(s.X%*%(gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),]));
          
          
          for(p in 1:N)
          {
            for(q in 1:N)
            {
              if(ta[q,p]==0)num.prob[q,p]=1 else num.prob[q,p]=(1-exp(-alpha.est*ta[q,p]))/(alpha.est*ta[q,p])
            }
          }
          cm1<-(s1/(2*alpha.est)+vy.est)*(1-exp(-2*alpha.est*ta))*exp(-alpha.est*tij)
          for(p in 1:N)
          {
            for(q in 1:N)
            {
              cm2[p,q]<-(((1-exp(-alpha.est*T[p]))/(alpha.est*T[p]))*((1-exp(-alpha.est*T[q]))/(alpha.est*T[q]))-(exp(-alpha.est*tia[p, q])*(1-exp(-alpha.est*T[p]))/(alpha.est*T[q])+ exp(-alpha.est*tja[p, q])*(1-exp(-alpha.est*T[p]))/(alpha.est*T[p]))*(num.prob[p,q]))
            }
          }
          
          
          mv<-diag(rowSums(matrix(data=as.numeric(me.pred)*t(kronecker(gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1), ], (1-(1-exp(-alpha.est*T))/(alpha.est*T)))^2), ncol=n.pred)));
          mcov<-diag(rowSums(matrix(data=as.numeric(me.cov)*t(kronecker(2*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),], (1-(1-exp(-alpha.est*T))/(alpha.est*T)))), ncol=n.pred)));
          mv.fixed<-diag(rowSums(matrix(data=as.numeric(me.fixed.pred)*t(kronecker(gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred), ], rep(1, times=N))), ncol=n.fixed.pred)));
          mcov.fixed<-diag(rowSums(matrix(data=as.numeric(me.fixed.cov)*t(kronecker(2*gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),], rep(1, times=N))), ncol=n.fixed.pred)));
          
          #V<-cm1+(s1*ta*cm2)+me.response+mv+ mv.fixed-mcov-mcov.fixed;
          V<-cm1+(s1*ta*cm2)+na.exclude(me.response)+ obs_var_con-mcov-mcov.fixed;
          
          
          V.inverse<-solve(V)
          beta.i.var<-pseudoinverse(t(X)%*%V.inverse%*%X)
          beta.i<-beta.i.var%*%(t(X)%*%V.inverse%*%Y)
          test<-matrix(nrow=(length(beta.i)))
          for(f in 1:(length(beta.i)))
          {
            if(abs(as.numeric(beta.i[f]-gls.beta1[f]))<=convergence) test[f]=0 else test[f]=1
          }
          if(sum(test)==0) break
          con.count=con.count+1
          if(con.count >= 50)
          {
            message("Warning, estimates did not converge after 50 iterations, last estimates printed out")
            break
          }
          
          
          gls.beta1<-beta.i
          
          mybiglist <- list()
          
          xx<-seq(from=1, to=length(Vu[,1]), by=N)
          mybiglist <- list()
          
          
          for (i in seq(from=1, to=nrow(gls.beta1), by=1)){
            for (j in seq(from=1, to=nrow(gls.beta1), by=1)) {
              tmp <- list(error_condition[xx[i]:(i*N),xx[j]:(j*N)]* gls.beta1[i]* gls.beta1[j])
              mybiglist[xx[i]+j] <- tmp
            }
          }
          
          
          mybiglist <-rmNullObs(mybiglist)
          obs_var_con<-Reduce('+', mybiglist)
          
          
          X<-cbind(weight.matrix(alpha.est, topology, times, N, regime.specs, fixed.pred, intercept), (1-(1-exp(-alpha.est*T))/(alpha.est*T))*pred)
          
          mv<-diag(rowSums(matrix(data=as.numeric(me.pred)*t(kronecker(gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1), ], (1-(1-exp(-alpha.est*T))/(alpha.est*T)))^2), ncol=n.pred)));
          mcov<-diag(rowSums(matrix(data=as.numeric(me.cov)*t(kronecker(2*gls.beta1[(n.fixed+1+n.fixed.pred):length(gls.beta1),], (1-(1-exp(-alpha.est*T))/(alpha.est*T)))), ncol=n.pred)));
          mv.fixed<-diag(rowSums(matrix(data=as.numeric(me.fixed.pred)*t(kronecker(gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred), ], rep(1, times=N))), ncol=n.fixed.pred)));
          mcov.fixed<-diag(rowSums(matrix(data=as.numeric(me.fixed.cov)*t(kronecker(2*gls.beta1[(n.fixed+1):(length(gls.beta1)-n.pred),], rep(1, times=N))), ncol=n.fixed.pred)));
          
          #V<-cm1+(s1*ta*cm2)+me.response+mv+ mv.fixed-mcov-mcov.fixed;
          V<-cm1+(s1*ta*cm2)+na.exclude(me.response) + obs_var_con-mcov-mcov.fixed;
          
          
          pred.mean<-X%*%gls.beta1
          g.mean<-(t(rep(1, times=N))%*%solve(V)%*%Y)/sum(solve(V));
          sst<-t(Y-g.mean)%*% solve(V)%*%(Y-g.mean)
          sse<-t(Y-pred.mean)%*%solve(V)%*%(Y-pred.mean)
          r.squared<-(sst-sse)/sst
          
          
          
        }
      }
      
      # END OF ITERATED GLS LOOP #
      
      ###### Start of Bias correction ######
      adj<-matrix(data=0, ncol= ncol(X), nrow=N)
      for(i in 1:(n.fixed.pred))
      {
        adj[,(n.fixed+i)]<-mean(X[,(n.fixed+i)])
      }
      for(i in 1:(n.pred))
      {
        adj[,(n.fixed+ n.fixed.pred +i)] <- as.numeric(sigma.X.estimate(pred[,i], me.pred[,i], topology, times)[1]);
      }
      V.inverse<-solve(V)
      correction<-matrix(Vu%*%pseudoinverse(Vd+Vu)%*%(c(X)-c(adj)),  ncol=ncol(X), nrow=nrow(X), byrow=F)
      bias_corr<-pseudoinverse(t(X)%*%V.inverse%*%X)%*%t(X)%*%V.inverse%*%correction
      m<-length(gls.beta1)
      K<-solve(diag(1,m,m)-bias_corr)
      corrected_betas<-solve(diag(1,m,m)-bias_corr)%*% gls.beta1
      ###### End of Bias correction ######
      
      
      
      
      
      
    } # END OF ESTIMATION MIXED MODEL ANCOVA
    
    
    
    if(model.type=="mfReg")
    {
      
      if(ultrametric==TRUE)
      {
        
        cat(c("   ", "t1/2  ", "Vy    ", "Supp  ", "K     ",if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov), if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), sep="   ");
        
      }
      
      else
        cat(c("   ", "t1/2  ", "Vy    ", "Supp  ", "Ya    ", "Xa    " ,"Bo    ", if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov), if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), sep="   ");
      
      message(" ");
      
      ## Establish grid_hl_vy, a vector of all possible hl + vy combinations
      grid_hl_vy <- cbind(sort(rep(half_life_values, length(vy_values)), decreasing = TRUE), rep(vy_values, length(half_life_values)))
      estimates <- apply(grid_hl_vy, 1, sup.mfReg, N, me.response, ta, tij, T.term, topology, times, model.type, ultrametric, Y, fixed.cov, pred, xx, beta1, error_condition, s.X, n.pred, num.prob, tia, tja, cm2, me.pred, me.cov, convergence, n.fixed, fixed.pred, n.fixed.pred, obs_var_con, me.fixed.cov, me.fixed.pred)
      sup2 <- sapply(estimates, function(e) e$support)
      gof <- matrix(sup2, ncol=length(vy_values), byrow=TRUE, dimnames = list(half_life_values, vy_values))
      
      
      ml<-max(na.exclude(gof))
      gof <- ifelse(gof <= ml-support, ml-support, gof) - ml
      
      
      which2 <- which(sup2 == max(na.exclude(sup2)))
      
      ## Find the regression for which the support value is maximized
      best.estimate <- estimates[[which.max(sup2)]]
      V.est <- best.estimate$V
      beta1.est <- beta1 <-  best.estimate$beta1
      beta1.var.est <- beta.i.var <- best.estimate$beta1.var
      X <- best.estimate$X
      alpha.est <- best.estimate$alpha.est
      vy.est <- best.estimate$vy.est
      
      ## Finalize beta, optimal regression
      if(ultrametric == TRUE){
        gls.beta1<- beta1.est
      }else{
        gls.beta1<- beta.i <- beta1.est
        ind.par<-matrix(data=0, nrow=N, ncol=4, dimnames=list(NULL, c("Bo", "Bi.Xia", "Yo", "Sum")))
        ind.par[,1]<-beta.i[1]*X[,1]
        ind.par[,2]<-(beta.i[2]*X[,2])
        ind.par[,3]<-beta.i[3]*X[,3]
        ind.par[,4]<-ind.par[,1]+ind.par[,2]+ind.par[,3]
        mean.Bo=mean(ind.par[,4])
      }
      

      ## Calculate ev.beta
      V.inverse <- solve(V.est)
      X1<-cbind(1, fixed.pred, pred)
      ##
      V.inverse <- solve(V.est)
      
      # Final estimation of evolutionary regression
      X1<-cbind(1, fixed.pred, pred)
      ev.beta.i.var<-pseudoinverse(t(X1)%*%V.inverse%*%X1)
      ev.beta.i<-ev.beta.i.var%*%(t(X1)%*%V.inverse%*%Y)
      glsyx.beta1<-ev.beta.i
      print(ev.beta.i)
      
      
      #print(beta1); print(glsyx.beta1)
      
      
      
      
      # # FINAL OPTIMAL REGRESSION USING BEST ALPHA AND VY ESTIMATES #
      # 
      # ev.beta.i.var<-pseudoinverse(t(X1)%*%V.inverse%*%X1)
      # ev.beta.i<-ev.beta.i.var%*%(t(X1)%*%V.inverse%*%Y)
      
      ## Calculate model fit stats
      pred.mean<-X%*%gls.beta1
      g.mean<-(t(rep(1, times=N))%*%solve(V.est)%*%Y)/sum(solve(V.est));
      sst<-t(Y-g.mean)%*% solve(V.est)%*%(Y-g.mean)
      sse<-t(Y-pred.mean)%*%solve(V.est)%*%(Y-pred.mean)
      r.squared<-(sst-sse)/sst
      
      ###### Start of Bias correction ######
      adj<-matrix(data=0, ncol= 1+ n.pred+n.fixed.pred, nrow=N)
      for(i in 1:(n.fixed.pred))
      {
        adj[,(1+i)]<-mean(X[,(1+i)])
      }
      for(i in 1:(n.pred))
      {
        adj[,(1+n.fixed.pred +i)] <- as.numeric(sigma.X.estimate(pred[,i], me.pred[,i], topology, times)[1])
      }
      if(ultrametric==TRUE) Vu<-Vu else Vu<-Vu[-(1:(2*N)),-(1:(2*N))]
      if(ultrametric==TRUE) Vd<-Vd else Vd<-Vd[-(1:(2*N)),-(1:(2*N))]
      correction<-matrix(Vu%*%pseudoinverse(Vd+Vu)%*%(c(X)-c(adj)),  ncol=ncol(X), nrow=nrow(X), byrow=F)
      bias_corr<-pseudoinverse(t(X)%*%V.inverse%*%X)%*%t(X)%*%V.inverse%*%correction
      m<-length(glsyx.beta1)
      corrected_betas<-solve(diag(1,m,m)-bias_corr)%*% glsyx.beta1
      
      
      ###### End of Bias correction ######
        
      } # END OF RANDOM AND FIXED COVARIATE REGRESSION ESTIMATION
    
  }# END OF FIXED AND RANDOM COVARIATE ANCOVA AND REGRESSION PARAMETER ESTIMATION
  #### END OF NEW CODE
  
  
  # PLOT THE SUPPORT SURFACE FOR HALF-LIVES AND VY
  
  
  if(length(half_life_values) > 1 && length(vy_values) > 1){
    #if(length(gof[gof>-2])){
      z1<-gof
      for(i in 1:length(vy_values)){
        h.lives[,i]=rev(z1[,i])
      }
      z<-h.lives
      x<-rev(half_life_values)
      y<-vy_values
      op <- par(bg = "white")
      
      # plot.slouch.x <<- x
      # plot.slouch.y <<- y
      # plot.slouch.loglik <<- z
      
      #persp(x, y, z, theta = plot.angle, phi = 30, expand = 0.5, col = "NA") ## plot.angle = 30 default
      persp(x, y, z, theta = plot.angle, phi = 30, expand = 0.5, col = "NA",
            ltheta = 120, shade = 0.75, ticktype = "detailed",
            xlab = "half-life", ylab = "vy", zlab = "log-likelihood")
    #}else{
      #print(sort(gof, decreasing = TRUE))
    #}
  }
  #plot.coord <- cbind(rep(x, length(y)), rep(rev(y), length(x)))
  
  
  
  
  
  # fixed.cov.names <- if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov)
  # random.cov.names <- if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)
  #
  # output5 <- list(model.type = model.type,
  #                 alpha.est = alpha.est,
  #                 vy.est = vy.est,
  #                 pred.mean = pred.mean,
  #                 g.mean = g.mean,
  #                 sst = sst,
  #                 sse = sse,
  #                 r.squared = r.squared,
  #                 ml = ml,
  #                 n.pred = n.pred,
  #                 ultrametric = ultrametric,
  #                 intercept = intercept,
  #                 N = N,
  #                 beta.est = beta.est,
  #                 theta.X = theta.X,
  #                 s.X = s.X,
  #                 beta.var.est = beta.var.est,
  #                 X = X,
  #                 x.ols = x.ols,
  #                 random.cov = random.cov,
  #                 corrected_betas = corrected_betas,
  #                 fixed.fact = fixed.fact,
  #                 random.cov.names = random.cov.names,
  #                 glsyx.beta1 = glsyx.beta1,
  #                 glsyx.beta1.var = glsyx.beta1.var,
  #                 fixed.cov = fixed.cov,
  #                 me.fixed.cov = me.fixed.cov,
  #                 fixed.cov.names = fixed.cov.names)
  #
  # result <- new("slouch", output5)
  # return(result)
  
  
  
  # MODEL OUTPUT
  # alpha, half-lives, correction factor, v
  
  
  message("==================================================")
  half.life<-log(2)/alpha.est
  c.factor<-mean(1-(1-exp(-alpha.est*T))/(alpha.est*T))
  modeloutput<-matrix(data=0, nrow=4, ncol=1, dimnames=list(c("Rate of adaptation ", "Phylogenetic half-life ","Phylogenetic correction factor", "Stationary variance "), "    Estimate"))
  modeloutput[1, 1]=alpha.est; modeloutput[2, 1]=half.life; modeloutput[3,1]=c.factor; modeloutput[4,1]=vy.est;   ##### Rememeber to output s.X
  
  
  
  
  
  modfit<-matrix(data=0, nrow=7, ncol=1, dimnames=list(c("Support", "AIC", "AICc", "SIC", "r squared", "SST", "SSE"),("Value")))
  
  
  #if(ultrametric==TRUE) n.par=1+n.pred else n.par=3+n.pred
  
  if(model.type=="ffANOVA" || model.type=="fReg" || model.type=="ffANCOVA") n.par<-length(gls.beta0)
  if(model.type == "mmANCOVA" || model.type=="rReg" || model.type=="mfReg" || model.type=="mmfANCOVA")   n.par<-length(beta1)
  
  modfit[1,1]=ml
  modfit[2,1]=-2*ml+2*(2+n.par)
  modfit[3,1]=modfit[2,1]+(2*(2+n.par)*((2+n.par)+1))/(N-(2+n.par)-1)
  modfit[4,1]=-2*ml+log(N)*(2+n.par)
  modfit[5,1]=r.squared*100
  modfit[6,1]=sst
  modfit[7,1]=sse
  
  message("");
  message("BEST ESTIMATES & MODEL FIT");message("");
  message("==================================================");
  message("MODEL PARAMETERS");
  print(modeloutput);message("");
  
  
  # predictor means and variances for random predictors
  
  if(model.type == "mmANCOVA" || model.type=="rReg" || model.type=="mfReg" || model.type=="mmfANCOVA")
  {
    print(matrix(data=rbind(theta.X, s.X), nrow=2, ncol=n.pred, dimnames=list(c("Predictor theta", "Predictor variance"), if(n.pred==1) deparse(substitute(random.cov)) else colnames(random.cov))));
    message("");
  }
  
  # PRIMARY OPTIMA OR REGRESSION SLOPE ESTIMATES
  
  message("--------------------------------------------------");
  message("PRIMARY OPTIMA");message("");
  
  
  if(model.type=="IntcptReg")
  {
    if(ultrametric==TRUE || alpha.est==Inf || alpha.est>=1000000000000000){
      Intercept<-matrix(nrow=1, ncol=2, dimnames=list(("Theta_global"), c("Estimate", "Std.error")))
      Intercept[,1]<-gls.beta0
      Intercept[,2]<-sqrt(beta.i.var)}
    else {
      Intercept<-matrix(data=0, nrow=2, ncol=1, dimnames=list(c("Bo", "Ya"), ("     Estimate")))
      Intercept[1,1]<-beta.i[1]
      Intercept[2,1]<-beta.i[2]
    }
    print(Intercept); message("")
  }
  
  if(model.type=="ffANOVA")
  {
    std<-sqrt(diag(beta.i.var))
    
    optima<-matrix(data=0, nrow=ncol(X), ncol=2, dimnames = list(colnames(X), c("Estimates", "Std.error")));
    optima[,1] = gls.beta0;
    optima[,2] = std;
    
    
    reg <- set.of.regimes(topology,regime.specs);
    root.reg<-as.character(regime.specs[times==0])
    nonroot.reg<-as.character(reg[reg != root.reg])
    
    
    if(is.null(intercept))
    {
      if(ncol(X) == length(reg)) message ("The ancestral state (Ya) parameter was dropped from this model as there is not enough information to estimate it")  else
        if(ncol(X)<length(reg)) message ("Ya and the parameter at the root were dropped") else
          message("this model does not drop Ya as it may influence the other parameters")
    }
    else
    {
      if(intercept=="root") message(root.reg, " ", "mapped to the root of the tree and includes the coefficent for the ancestral state (Ya)") else
        message("you set the intercept coefficent to a value of", " ", intercept,". Ya is not the true ancestral state anymore")
    }
    print(optima);message("");
  }
  
  
  if(model.type== "fReg")
  {
    std<-sqrt(diag(beta.i.var))
    
    optima<-matrix(data=0, nrow=(nrow(gls.beta0)), ncol=2, dimnames=list(c("Bo", if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov)), c("Estimate", "Std. Error")))
    optima[,1] = gls.beta0;
    optima[,2] = std;
    
    
    corrected_beta_values<-matrix(data= c(corrected_betas), nrow=(nrow(beta1)), ncol=1, dimnames=list(c("Bo", if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov)), c("Bias-corr. regression parameters")))
    
    
    print(optima);message("");message("");
    print(corrected_beta_values);message("");
    
  }
  
  if(model.type=="ffANCOVA")
  {
    std<-sqrt(diag(beta.i.var))
    
    
    optima<-matrix(data=0, nrow=ncol(X), ncol=2, dimnames = list(c(as.character(levels(fixed.fact)), if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov)), c("Estimates", "Std.error")));
    optima[,1] = gls.beta0;
    optima[,2] = std;
    
    corrected_beta_values<-matrix(data= c(corrected_betas), nrow=(nrow(beta1)), ncol=1, dimnames = list(c(as.character(levels(fixed.fact)), if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov)), c("Bias-corr. regression parameters")));
    
    print(optima);message("");message("");
    print(corrected_beta_values);message("");
    
  }
  
  
  
  if(model.type  == "mmANCOVA")
  {
    std<-sqrt(diag(beta.i.var))
    if(length(X[1,]) > length(x.ols[1,])) optima<-matrix(data=0, nrow=ncol(X), ncol=2, dimnames = list(c(c("Ya",as.character(levels(fixed.fact))), if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimates", "Std.error")))
    else
      
      optima<-matrix(data=0, nrow=ncol(X), ncol=2, dimnames = list(c(as.character(levels(fixed.fact)), if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimates", "Std.error")));
    
    corrected_beta_values<-matrix(data= c(corrected_betas), nrow=(nrow(beta1)), ncol=1, dimnames = list(c(as.character(levels(fixed.fact)), if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Bias-corr. regression parameters")));
    
    
    optima[,1] = gls.beta1;
    optima[,2] = std;
    print(optima);message("");message("");
    print(corrected_beta_values);message("");
  }
  
  if(model.type  == "mmfANCOVA")
  {
    std<-sqrt(diag(beta.i.var))
    
    if(length(X[1,]) > length(x.ols[1,])) optima<-matrix(data=0, nrow=ncol(X), ncol=2, dimnames = list(c(c("Ya",as.character(levels(fixed.fact))),if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov), if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimates", "Std.error")))
    else
      
      optima<-matrix(data=0, nrow=ncol(X), ncol=2, dimnames = list(c(as.character(levels(fixed.fact)), if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov),if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimates", "Std.error")));
    
    corrected_beta_values<-matrix(data= c(corrected_betas), nrow=(nrow(beta1)), ncol=1, dimnames = list(c(as.character(levels(fixed.fact)), if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov),if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Bias-corr. regression parameters")))
    
    
    optima[,1] = gls.beta1
    optima[,2] = std
    print(optima);message("");message("")
    print(corrected_beta_values);message("")
  }
  if(model.type=="rReg")
  {
    if(ultrametric==TRUE || alpha.est == Inf)
      opreg<-matrix(data=0, nrow=(nrow(gls.beta1)), ncol=2, dimnames=list(c("K", if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimate", "Std. Error")))
    else
    {
      if(alpha.est != Inf)
        opreg<-matrix(data=0, nrow=(nrow(gls.beta1)), ncol=2, dimnames=list(c("Xa", "Bo","Ya" ,if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimate", "Std. Error")))
      else opreg<-matrix(data=0, nrow=(nrow(gls.beta1)), ncol=2, dimnames=list(c("K", if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimate", "Std. Error")))}
    
    opreg[,1] =round(gls.beta1, 5)
    opreg[,2]= round(sqrt(diag(beta.i.var)),5)
    
    
    corrected_beta_values<-matrix(data= c(corrected_betas), nrow=(nrow(beta1)), ncol=1, dimnames=list(c("K", if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Bias-corr. regression parameters")))
    
    if(model.type=="rReg")
    {
      
      evreg<-matrix(data=0, nrow=(nrow(glsyx.beta1)), ncol=2, dimnames=list(c("Intercept", if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimate", "Std. Error")))
      
      
      evreg[,1] =round(glsyx.beta1, 5)
      evreg[,2]= round(sqrt(diag(ev.beta.i.var)),5)
      
      message("Evolutionary regression"); message("")
      print(evreg);
      message("");
    }
    message("Optimal regression"); message("")
    print(opreg);message("");message("");
    
    print(corrected_beta_values); message("");
    
    if(model.type=="rReg" && ultrametric==TRUE && alpha.est != Inf)
    {
      message("")
      message("Decomposition of K assuming Ya = Xa to get the optimal regression intercept Bo")
      message("")
      
      bo<-opreg[1,1] + (c.factor-1)*(sum(gls.beta1[-1]*theta.X))
      print(bo)
      message("")
      message("(Use this as the intercept when plotting the regression line)")
      
      message("")
    }
  }
  
  
  if(model.type=="mfReg")
  {
    if(ultrametric==TRUE || alpha.est == Inf)
      opreg<-matrix(data=0, nrow=(nrow(gls.beta1)), ncol=2, dimnames=list(c("K",if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov),if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimate", "Std. Error")))
    else
    {
      if(alpha.est != Inf)
        opreg<-matrix(data=0, nrow=(nrow(gls.beta1)), ncol=2, dimnames=list(c("Xa", "Bo","Ya" ,if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov),if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimate", "Std. Error")))
      else opreg<-matrix(data=0, nrow=(nrow(gls.beta1)), ncol=2, dimnames=list(c("K", if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov),if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimate", "Std. Error")))}
    
    opreg[,1] =round(gls.beta1, 5)
    opreg[,2]= round(sqrt(diag(beta.i.var)),5)
    
    if(model.type=="mfReg")
    {
      
      evreg<-matrix(data=0, nrow=(nrow(glsyx.beta1)), ncol=2, dimnames=list(c("Intercept",if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov), if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Estimate", "Std. Error")))
      
      corrected_beta_values<-matrix(data= c(corrected_betas), nrow=(nrow(beta1)), ncol=1, dimnames=list(c("Intercept",if(is.null(dim(fixed.cov))) deparse(substitute(fixed.cov)) else colnames(fixed.cov), if(is.null(dim(random.cov))) deparse(substitute(random.cov)) else colnames(random.cov)), c("Bias-corr. regression parameters")))
      
      evreg[,1] =round(glsyx.beta1, 5)
      evreg[,2]= round(sqrt(diag(ev.beta.i.var)),5)
      
      message("Evolutionary regression"); message("")
      print(evreg);
      message("");
    }
    message("Optimal regression"); message("")
    print(opreg);message("");message("");
    
    print(corrected_beta_values); message("");
    
    if(model.type=="mfReg" && ultrametric==TRUE && alpha.est != Inf)
    {
      message("")
      message("Decomposition of K assuming Ya = Xa to get the optimal regression intercept Bo")
      message("")
      
      bo<-opreg[1,1] + (c.factor-1)*(sum(gls.beta1[-(1:(1+n.fixed.pred))]*theta.X))
      print(bo)
      message("")
      message("(Use this as the intercept when plotting the regression line)")
      
      message("")
    }
  }
  
  message("--------------------------------------------------");
  message("MODEL FIT");message("");
  print(modfit); message("");
  message("==================================================");
  
  print("debug: model.fit.dev")
  
  
} # END OF MODEL FITTING FUNCTION


